'''
Accepted on leetcode(924)
time - O(M*N)
space - O(N)
Approach:
1. Create 3 arrays - colors, group and initColors.
2. Iterate over initial and look for 1 in initColors and check 3 conditions for it.
3. Then atlast no 1 is found in initColors return minimum index from initial as answer.
'''


class Solution:
    def minMalwareSpread(self, graph, initial) -> int:
        n = len(graph)

        color = [-1 for i in range(n)]
        c = 0  # color
        for i in range(n):
            if color[i] == -1:
                # call dfs - to build(initialize) colors array
                self.dfs(graph, color, i, c)
                c += 1

        # create group array by counting elements in each color
        group = [0 for i in range(c)]
        for i in range(n):
            group[color[i]] += 1

        # create initcolors array - count the malware effected nodes into different color groups.
        initColor = [0 for i in range(c)]
        for node in initial:
            initColor[color[node]] += 1

        ans = float("inf")

        for node in initial:
            nodeColor = color[node]
            if initColor[nodeColor] == 1:
                if ans == float("inf"):  # only one element is effected in one group
                    ans = node
                elif group[nodeColor] > group[color[
                    ans]]:  # only one element is effected in 2 groups but size of ne group is greater than another, so save larger group.
                    ans = node
                elif group[nodeColor] == group[color[ans]] and ans > node:
                    ans = node
        if ans == float("inf"):
            for node in initial:
                ans = min(ans, node)
        return ans

    def dfs(self, graph, color, node, c):
        color[node] = c
        for x in range(len(graph)):
            if graph[node][x] == 1 and color[x] == -1:
                self.dfs(graph, color, x, c)


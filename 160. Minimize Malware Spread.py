class Solution:
    colors = 0
    n = 0

    def minMalwareSpread(self, graph, initial):

        self.n = len(graph)
        self.colors = [-1] * self.n

        cl = 0

        for i in range(self.n):
            if self.colors[i] == -1:
                self.dfs(graph, i, cl)
                cl += 1
        # print(self.colors, cl)
        groups = [0] * cl

        for i in range(self.n):
            color = self.colors[i]
            groups[color] += 1
        # print(groups)
        initGroup = [0] * cl

        for node in initial:
            c = self.colors[node]
            initGroup[c] += 1

        # print(initGroup)

        result = float("inf")

        for node in initial:
            col = self.colors[node]
            if initGroup[col] == 1:
                if result == float("inf"):
                    result = node
                elif groups[self.colors[node]] > groups[self.colors[result]]:
                    result = node
                elif groups[self.colors[node]] == groups[self.colors[result]] and node < result:
                    result = node

        if result == float("inf"):
            # print("this")
            for node in initial:
                result = min(result, node)

        return result

    def dfs(self, graph, i, cl):
        # base
        if self.colors[i] != -1:
            return

            # logic
        self.colors[i] = cl
        for j in range(self.n):
            if graph[i][j] == 1:
                self.dfs(graph, j, cl)


# graph_1 = [[0,1],[1,2],[2,0],[1,3]]
# initial_1 = [[1,3]]
obj = Solution()
obj.minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1])
# obj.dfs([[0,1],[1,2],[2,0],[1,3]])

# Graph , DFS
# Time Complexity: O(n^2)
# Did this code successfully run on Leetcode : Yes
# Any problem you faced while coding this : No
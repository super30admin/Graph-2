/* 
    Time Complexity                              :  O(N*N) - to find the connected components i.e. number of colors in the graph
                                                    O(N) - to find the count of groups
                                                    O(I) - to find the count of infected node colors where I is the length of the initial array
                                                    O(I) - to find the minimum Index if it exists, where I is the length of the initial array
                                                    O(I) - to find the minimum index if it doesn't exist, where I is the length of the initial array
                                                    Hence overall O(N*N)

    Space Complexity                             :  size of colors array + size of groups array + size of infected array = O(3*N) in the worst case
    Did this code successfully run on Leetcode   :  Yes
    Any problem you faced while coding this      :  No
*/

#include <bits/stdc++.h> 
using namespace std;  

class Solution {
private:
    vector<vector<int>> dirs{{-1,0},{1,0},{0,-1},{0,1}};
    vector<int> colors;
    
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        
        // number of connected components int the graph = number of colors
        int clr = 0;
        colors.resize(n,-1);
        for(int i=0;i<n;i++) {
            if(colors[i] == -1) {
                dfs(graph,i,clr);
                clr++;
            }
        }
        
        // cout << "Colors" << "\n";
        // for(int i=0;i<colors.size();i++) {
        //     cout << i << " - " << colors[i] << "\n";
        // }
        
        // how many nodes have the same color i.e. these nodes are connected. 
        // we will check if the infected node is among these groups and try to remove the 
        // infected node if by removing it we can save maximum number of nodes i.e. why we need this groups array.
        vector<int> groups(clr,0);
        for(int i=0;i<n;i++) {
            groups[colors[i]]++;
        }
        
        // cout << "Groups" << "\n";
        // for(int i=0;i<clr;i++) {
        //     cout << i << " - " << groups[i] << "\n";
        // }
        
        
        // for the initial infected nodes given, count the colors each one is associated to
        // if a color is associated with more than one infected node, it means, even if we remove an infected node, 
        // the other non-infected nodes will be infected by the other infected node
        vector<int> infected(clr,0);
        for(auto node : initial) {
            int infectedNodeColor = colors[node];
            infected[infectedNodeColor]++;
        }
        
        // infected
        // cout << "Infected" << "\n";
        // for(int i=0;i<infected.size();i++) {
        //     cout << i << " - " << infected[i] << "\n";
        // }
        
        int mnIdx = INT_MAX;
        for(auto infectedNode : initial) {
            
            int infectedNodeColor = colors[infectedNode];
            int mnIdxColor = mnIdx == INT_MAX ? 0 : colors[mnIdx];
            
            if(infected[infectedNodeColor] == 1)  {
                if(mnIdx == INT_MAX) {
                    mnIdx = infectedNode;
                } 
                else if(groups[infectedNodeColor] > groups[mnIdxColor]) { // more number of nodes can be removed by removing the current infected node 
                    mnIdx = infectedNode;
                } 
                else if(groups[infectedNodeColor] == groups[mnIdxColor]) {
                    mnIdx = min(infectedNode, mnIdx);
                }
            }
        }
        
        // if we have more than one infected node in each group it means we cannot save any group
        // hence we provide the lowest index
        if(mnIdx == INT_MAX) {
            for(auto infectedNode : initial) {
                mnIdx = min(mnIdx, infectedNode);
            }
        }
        
        return mnIdx;
    }
    
    
    void dfs(vector<vector<int>>& graph, int i, int clr) {
        if(colors[i] != -1) return;
        
        colors[i] = clr;
        
        for(int j=0;j<graph.size();j++) {
            if(graph[i][j] == 1) {
                dfs(graph,j,clr);
            }
        }
        
    }
};
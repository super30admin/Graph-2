    /*  Explanation
    # Leetcode problem link : https://leetcode.com/problems/minimize-malware-spread/
    Time Complexity for operators : o(n^2) .. V - vertex, E - edges
    Extra Space Complexity for operators : o(n) .. no o elements
    Did this code successfully run on Leetcode : NA
    Any problem you faced while coding this : No
# Your code here along with comments explaining your approach
        # Basic approach : 
        # Optimized approach: 
                              
            # 1. 
                    A) 
*/

class Solution {
    
    int[] colors; 
    int n;
    
    public int minMalwareSpread(int[][] graph, int[] initial) {
        n = graph.length;
        colors = new int[n];
        
        Arrays.fill(colors, -1);
        
        int curr_color = 0;
        
        for(int i = 0; i < n; i++){
            if(colors[i] == -1){
                dfs(graph, i, curr_color);
            }
            curr_color += 1;
        }
        
        // create groups
        int[] groups = new int[curr_color];
        
        for(int i=0;i<n;i++){
            groups[colors[i]] += 1;
        }
        
        // create affected
        int[] affected = new int[curr_color];
        for(int init : initial){
            affected[colors[init]] += 1;
        }
        
        int result = Integer.MAX_VALUE;
        
        for(int init: initial){
            int color = colors[init];
            
            if(affected[color] == 1){
                if(result == Integer.MAX_VALUE){
                    result = init;
                }else if(groups[color] > groups[colors[result]]){
                    result = init;
                }else if(groups[color] == groups[colors[result]] && result > init){
                    result = init;
                }
            }
        }
        
        if(result == Integer.MAX_VALUE){
            for(int init : initial){
                result = Math.min(result, init);
            }
        }
        
        return result;
    }
    
    private void dfs(int graph[][], int i, int curr_color){
        // valid
        colors[i] = curr_color;
        
        for(int j = 0; j < n; j++){
            if(i != j && graph[i][j] == 1 && colors[j] == -1){
               dfs(graph, j, curr_color); 
            }
        }
    }
}
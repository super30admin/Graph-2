from typing import List
from collections import defaultdict, Counter


class Solution:

    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        """
             https://leetcode.com/problems/minimize-malware-spread/
             Time Complexity - O(V*E)
             'V' -> vertices
             'E' -> edges
             Space Complexity - O(V)
        """
        self.n = len(graph)
        self.colors = [-1] * self.n
        c = 0
        for i in range(self.n):
            self._dfs(i, c, graph)
            c += 1

        groups = Counter(self.colors)
        init_color = [0] * c
        for node in initial:
            init_color[self.colors[node]] += 1

        result = float('inf')
        for node in initial:
            color = self.colors[node]
            count = init_color[color]
            if count == 1:
                if result == float('inf'):
                    result = node
                elif groups[color] > groups[self.colors[result]]:
                    result = node
                elif groups[color] == groups[self.colors[result]] and node < result:
                    result = node
        if result == float('inf'):
            return min(initial)
        return result

    def _dfs(self, node, color, graph):
        # base
        if self.colors[node] != -1:
            return
        # logic
        self.colors[node] = color
        for i in range(self.n):
            if graph[node][i] == 1:
                self._dfs(i, color, graph)

    # def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
    #     """
    #          https://leetcode.com/problems/minimize-malware-spread/
    #          Time Complexity -
    #          Space Complexity -
    #     """
    #     adj_matrix = defaultdict(list)
    #     initial = sorted(initial)
    #     # graph
    #     for node in range(len(graph)):
    #         for edge in range(len(graph[0])):
    #             if graph[node][edge] == 1:
    #                 adj_matrix[node].append(edge)
    #     # make groups
    #     groups = {}
    #     counts = {}
    #     g_name = 0
    #     min_group_name = None
    #     max_group_size = float('-inf')
    #     visited = set()
    #     for node in initial:
    #         group, infected_count = self._dfs(initial, visited, adj_matrix, node)
    #         if group:
    #             groups[g_name] = group
    #             counts[g_name] = infected_count
    #             if infected_count == 1 and len(group) > max_group_size:
    #                 max_group_size = len(group)
    #                 min_group_name = g_name
    #             g_name += 1
    #     if min_group_name is None:
    #         return min(initial)
    #     return min(set(initial).intersection(groups[min_group_name]))
    #
    # def _dfs(self, initial, visited, adj_matrix, root):
    #     if root in visited:
    #         return None, None
    #     stack = [root]
    #     result = []
    #     initial_count = 0
    #     while stack:
    #         cur = stack.pop()
    #         if cur in initial:
    #             initial_count += 1
    #         for edge in adj_matrix[cur]:
    #             if edge != cur and edge not in visited:
    #                 stack.append(edge)
    #         if cur not in visited:
    #             visited.add(cur)
    #             result.append(cur)
    #     return result, initial_count


if __name__ == '__main__':
    print(Solution().minMalwareSpread([[1, 1, 1], [1, 1, 1], [1, 1, 1]], [1, 2]))
    print(Solution().minMalwareSpread([[1, 1, 0], [1, 1, 0], [0, 0, 1]], [0, 1]))
    print(Solution().minMalwareSpread([[1, 0, 0], [0, 1, 0], [0, 0, 1]], [0, 2]))
    print(Solution().minMalwareSpread([[1, 1, 0], [1, 1, 0], [0, 0, 1]], [0, 1, 2]))
    print(Solution().minMalwareSpread([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1]], [3, 1]))
    print(Solution().minMalwareSpread(
        [[1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 0],
         [0, 0, 0, 0, 0, 1]], [5, 0]))

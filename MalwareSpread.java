// Time Complexity : O(n^2) where n is the number of nodes
// Space Complexity : O(n) for groups array, initial groups
// Did this code successfully run on Leetcode : Yes
// Any problem you faced while coding this : Graph coloring problem to get solution
/* Your code here along with comments explaining your approach: Divide the nodes into groups with each group constituting a different color starting from 0 to n-1.
Do the dfs till you color all the group of nodes. Count the number of nodes in each group and place it into groups array. Then use the initial array
to find which colored nodes are infected nodes and count the number of such colored nodes present. Compare the intial group with groups array so that
if we have more than one infected node then ignore else if we have only one infected node, then see how many nodes can be saved from groups array. 
Similarly, if the count is same for two different colors check the groups array and keep the max corresponding value in groups to the initial group.
*/
class Solution {
    int[] colors;
    int n;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        if(graph == null || graph.length  == 0) return 0;
        n = graph.length;
        colors = new int[n];
        Arrays.fill(colors, -1);
        int c = 0;
        for(int i = 0; i < n; i++){
            dfs(i, graph,c);                                                                // DFS to color the group of nodes
            c++;
        }
        int[] groups = new int[c];
        for(int i : colors){
            groups[i]++;                                                                                    // Count the number of nodes in each color
        }
        int[] initialGroup = new int[c];
        for(int i : initial){
            initialGroup[colors[i]]++;                                                                          // how many nodes in a particular color are infected
        }
        int count = 0;
        boolean flag = false;
        int index  = Integer.MAX_VALUE;
        for(int i = 0; i < initial.length; i++){
            int cl = colors[initial[i]];
            if(initialGroup[cl] == 1){                                                                   // If the group has only one infected node
                if(groups[cl] >= count){                                
                flag = true;
                count = groups[cl];                                                                     // Get the number of nodes that can be saved
                if(groups[cl] == count) index = Math.min(index, initial[i]);                            // If equal count, keep the smallest index node
                else index  = initial[i];                                                               // if unequal, keep the node saving max value in groups
            } 
        }
        }
        if(flag == false){
            for(int i: initial){                                                                        // If nothing could be saved, keep the smallest node value
                index = Math.min(index, i);
            }
        }
        return index;
    }
    private void dfs(int node, int[][] graph, int c){
        if(colors[node] != -1) return;
        colors[node] = c;
        for(int i = 0; i< n; i++){
            if(graph[node][i] == 1){                                                                    // If there is a connection, explore the group
                dfs(i, graph, c);
            } 
        }
    }
}
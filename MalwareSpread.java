//TC : O(VE)
//SC : O(V) ,Space for the colors array
class Solution {
    int[] colors;int n;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        
         n = graph.length;
        colors = new int[n];
        Arrays.fill(colors,-1);
        int c = 0;
        //Preprocessing
        
        //STEP1 : Create colors array
        for(int i=0;i<n;i++){
            dfs(i,graph,c);
            c++;
        }
        
        //STEP2 : Create groups array
        int[] groups = new int[c];
        for(int i=0;i<colors.length;i++){
            groups[colors[i]]++;
        }
        
        //STEP3:Create infected colors array
        int[] infectedColor = new int[c];
        for(int node : initial){
            int color = colors[node];
            infectedColor[color]++;
        }
        
        //PostProcessing
        int result = Integer.MAX_VALUE;
        for(int node : initial){
            int color = colors[node];
            int count = infectedColor[color];
            
            if(count == 1){
                if(result == Integer.MAX_VALUE) result = node;
                //Checking the impact -> how many nodes can be saved
                else if(groups[color] > groups[colors[result]]) result = node;
                //if the number of nodes that can be saved are same,return smaller index
                else if(groups[color] == groups[colors[result]] && node<result) result = node;
            }
        }
        
        if(result == Integer.MAX_VALUE){
            for(int i : initial){
                result = Math.min(result,i);
            }
        }
        
        
        
        return result;
    }
    private void dfs(int node,int[][] graph,int color){
        if(colors[node]!=-1)
            return;
        colors[node] = color;
        for(int i=0;i<n;i++){
            if(graph[node][i] == 1)
                dfs(i,graph,color);
        }
    }
    
}
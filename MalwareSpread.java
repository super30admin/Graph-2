//time o(n pow 2)
//space o(n)
//algorithm
//color code the all nodes
//see how many nodes belong to particular group based on color
//see how many initial nodes belong to a specific group
// if group cnt ==1 then removing that nodes will save all nodes in that grp
//get the node which saves max nodes.
class Solution {
    int[] colors;
    int nodes; 
    public int minMalwareSpread(int[][] graph, int[] initial) {
        nodes = graph.length;
        colors = new int[nodes];
        Arrays.fill(colors, -1);
        int color = 0;
        for(int i=0; i<nodes; i++) {
            dfs(i, graph, color);
            color++;
        }
        //at line 11 color is already incremented before terminating the loop
        int[] groups = new int[color];
        //check the colors, for same colors increment the group count
        for(int node: colors) {
            groups[node]++;
        }
        
        int[] initialGroup = new int [color];
        for(int node : initial) {
            int c = colors[node]; //color
            initialGroup[c]++;
        }
        
        int res = Integer.MAX_VALUE;
        for(int node: initial) {
            //see how many initial nodes are affected in the grp which this node belongs
            int c = colors[node]; //color
            int cnt = initialGroup[c];
            if(cnt == 1) {
                if(res == Integer.MAX_VALUE) {
                    res = node;
                }
                else if(groups[c] > groups[colors[res]]) {
                    res = node;
                }
                else if(groups[c] == groups[colors[res]] && node < res){
                    res = node;
                }
            }
        }
        
        if(res == Integer.MAX_VALUE) {
            for(int node : initial) {
                res = Math.min(node, res);
            }
        }
        return res;
    }
    
    private void dfs(int node, int[][] graph, int color) {
        //base case
        if(colors[node] != -1) {
            return;
        }
        //logic
        colors[node] = color;
        for(int j=0; j<nodes; j++) {
            if(graph[node][j] == 1)
            {
                //connection is there
                dfs(j, graph, color);
            }
        }
    }
}
import java.util.Arrays;

public class MinMalware {
    // TC : O(n^2)
    // SC : O(n)
    int n;
    int[] colors;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        if(graph == null || graph.length == 0) return 0;

        n = graph.length;
        colors = new int[n];
        Arrays.fill(colors, -1);
        int c = 0;

        // creating colors array
        for(int i=0; i < n; i++){
            if(colors[i] == -1){
                dfs(graph, i,c);
                c++;
            }
        }

        // creating groups array
        int[] groups = new int[c];
        for(int i=0; i < n; i++) {
            int color = colors[i];
            groups[color]++;
        }

        // creating infected array
        int[] infected = new int[c];
        for(int i=0; i < initial.length; i++) {
            int color = colors[initial[i]];
            infected[color]++;
        }

        int answer = Integer.MAX_VALUE;
        for(int i=0; i < initial.length;i++) {
            int color = colors[initial[i]];
            if(infected[color] == 1) {
                if(answer == Integer.MAX_VALUE){
                    answer = initial[i];
                }else if(groups[colors[answer]] < groups[color]) {
                    answer = initial[i];
                }else if(groups[colors[answer]] == groups[color] && initial[i] < answer) {
                    answer = initial[i];
                }
            }
        }

        if(answer == Integer.MAX_VALUE){
            for(int i=0; i < initial.length; i++){
                answer = Math.min(answer,initial[i]);
            }
        }

        return answer;
    }

    private void dfs(int[][] graph, int i, int c) {
        if(colors[i] != -1) return;

        colors[i] = c;
        for(int j=0; j < n; j++){
            if(graph[i][j] == 1){ // start the recursion only if i & j are connected
                dfs(graph, i, c);
            }
        }
    }
}

// Time Complexity : O(N ^ 2)
// Space Complexity : O(N)
// Did this code successfully run on Leetcode : Yes
// Any problem you faced while coding this : NA


// Your code here along with comments explaining your approach

class Solution {
    int[] colors;
    int n;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        
        n = graph.length;
        colors = new int[n];
        Arrays.fill(colors, -1);
        int color = 0;
        
        for(int i = 0; i < n; i++) {
            dfs(i, color, graph);
            color++;
        }
        
        int[] groups = new int[color];
        
        for(int cl: colors) {
            groups[cl]++;
        }
        
        int[] infGroups = new int[color];
        
        for(int in: initial) {
            int cl = colors[in];
            infGroups[cl]++;
        }
        
        int result = Integer.MAX_VALUE;
        
        for(int node : initial) {
            
            int cl = colors[node];
            int totalInfected = infGroups[cl];
            
            if(totalInfected == 1) {
                if(result == Integer.MAX_VALUE) {
                    result = node;
                }
                else if(groups[cl] > groups[colors[result]]) {
                    result = node;
                }
                else if(groups[cl] == groups[colors[result]] && node < result) {
                    result = node;
                }
            }
        }
        
        if(result == Integer.MAX_VALUE) {
            for(int node : initial) {
                result = Math.min(node, result);
            }
        }
        
        return result;
    }
    
    private void dfs(int node, int color, int[][] graph) {
        
        if(colors[node] != -1) return;
        
        colors[node] = color;
        
        for(int i = 0; i < n ; i++) {
            if(graph[node][i] == 1) {
                dfs(i, color, graph);
            }
        }
    }
}
------------------------Minimum Malware Spread------------------------------------------
# Time Complexity : O(V+E) as V is number of vertices and E number of edges 
# Space Complexity : O()  No extra space
# Did this code successfully run on Leetcode : Yes
# Any problem you faced while coding this : No
# 
#Algorithm
# 1. Find the Connected component nodes
# 2. Color graph of nodes based on the connections
# 3. Number of nodes in each color
# 4. go through initial list and check how many nodes are infected in each color
# 5. if it is one we can remove that node, else we need to check which malware node will save maximum number of other nodes in component.
        


class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        
        if not graph:
            return []
        
        def dfs(node, graph, color):
            if colors[node] != -1:
                return 
            
            colors[node] = color
            for j in range(n):
                if graph[node][j] == 1:
                    dfs(j, graph, color)
            
            
        n = len(graph)
        colors = [-1 for i in range(n)]
        c = 0
        for i in range(n):
            dfs(i, graph,c)
            c+=1
        
        groups = [0 for i in range(c)]
        for i in colors:
            groups[i] +=1
        
        initgroups = [0 for i in range(c)]
        for j in initial:
            initgroups[colors[j]]+=1
        
        result = float('inf')
        for j in initial:
            cl = colors[j]
            count = initgroups[cl]
            if count == 1:
                if result == float('inf'):
                    result = j
                elif groups[colors[j]] >groups[colors[result]]:
                    result = j
                elif groups[colors[j]] ==groups[colors[result]] and result>j:
                    result = j
        return result if result != float('inf') else min(initial)
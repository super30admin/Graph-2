// Time Complexity : O(E+V) 
// Space Complexity : O(E+V) 

class Solution {
    int[] colors;
    int n;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        n = graph.length;
        colors = new int[n];
        Arrays.fill(colors, -1);
        int c = 0;
        for (int i = 0; i < n; i++) {
            dfs(i, c, graph);
            c++;
        }
        int[] groupCounts = new int[c];
        for (int i : colors) {
            groupCounts[i]++;
        }
        int[] initCounts = new int[c];
        for (int i : initial) {
            int color = colors[i];
            initCounts[color]++;
        }
        int ans = Integer.MAX_VALUE;
        for (int node : initial) {
            int color = colors[node];
            int count = initCounts[color];
            if (count == 1) {
                if (ans == Integer.MAX_VALUE) {
                    ans = node;
                }
                else if (groupCounts[color] > groupCounts[colors[ans]]) {
                    ans = node;
                }
                else if (groupCounts[color] == groupCounts[colors[ans]] && node < ans) { 
                    ans = node;
                }
            }
        }
        if (ans == Integer.MAX_VALUE) {
            for (int node : initial) {
                ans = Math.min(ans, node);
            }
        }
        return ans;
    }
    private void dfs(int node, int color, int[][] graph) {
        // base case
        if (colors[node] != -1) return; 
        // logic
        colors[node] = color;
        for (int i = 0; i < n; i++) {
            if (graph[node][i] == 1) {
                dfs(i, color, graph);
            }
        }
    }
}
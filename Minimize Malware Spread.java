// Time Complexity : O(V^2)
// Space Complexity : O(V)
// Method used : DFS

class Solution {

    int n;

    public int minMalwareSpread(int[][] graph, int[] initial) {
        
        if(graph == null || graph.length == 0) return 0;

        n = graph.length;

        int[] colors = new int[n];
        Arrays.fill(colors, -1);

        // The first step is to assign colors to connected components;
        int color = 0;

        // Traverse through all the nodes in the graph
        for(int i = 0 ; i < n; i++)
        {
            if(colors[i] == -1)
            {
                dfs(colors, graph, color, i);
                ++color;
            }
        }

        // Now let's create a groups array which will tells us how many nodes are presnt in each color(connected component)
        int[] groups = new int[color];

        for(int i = 0 ; i < n; i++)
        {
            int index = colors[i];
            groups[index]++;
        }

        // Now we should also keep track of initially infected nodes which had malware. Traverse the given initial array and keep
        // track to which color(connect component) they belong to

        int[] initially_infected = new int[color];

        for(int i = 0; i < initial.length; i++)
        {
            // initial[i] will give us the node, we need the color of this node

            int index = colors[initial[i]];

            // Now we need this index to update in initially_infected array
            initially_infected[index]++;
        }

        // Now I again traverse the given initial array. The intention here is we need to find to which color(connected component)
        // this malware node belongs to. This is bcoz that particular connected component might have multiple malware nodes
        // In that case we can ignore that component. We should focus on components which has only one malware node

        int answer = Integer.MAX_VALUE;

        for(int i = 0; i < initial.length; i++)
        {
            // Use this node as index to get the color of node
            int node = initial[i];

            int get_color = colors[node];

            if(initially_infected[get_color] == 1)
            {
                if(answer == Integer.MAX_VALUE) answer = node;

                // Pick the malware node which has more number of nodes in the connected component. This way we can ensure that we are
                // saving more number of nodes by removing malware
                else if(groups[get_color] > groups[colors[answer]]) answer = node;

                // This means both these nodes have same number fo nodes in it's connected components. In that case return the node 
                // with minimum value
                else if(groups[get_color] == groups[colors[answer]])
                    answer = Math.min(node, answer);
            }
        }

        // It could be the case that none of the connected components gave the answer. In this case we traverse the given initial 
        // array and choose the node which has minimum value;
        if(answer == Integer.MAX_VALUE)
        {
            int minimum = Integer.MAX_VALUE;

            for(int num : initial) minimum = Math.min(minimum, num);

            return minimum;
        }

        return answer;
    }

    private void dfs(int[] colors, int[][] graph, int color, int node)
    {
        // This node is already visited
        if(colors[node] != -1) return;

        // Assign the color to this node
        colors[node] = color;

        // Traverse the nodes which are connected to this current node
        for(int j = 0; j < n; j++)
        {            
            if(graph[node][j] == 1)
            {
                dfs(colors, graph, color, j);
            }
        }
    }
}
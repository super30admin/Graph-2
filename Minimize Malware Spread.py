""""// Time Complexity : O(n^2)
// Space Complexity :O(n)
// Did this code successfully run on Leetcode : Yes
// Any problem you faced while coding this :
"""

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        if graph == None:
            return -1
        n = len(graph)

        self.colors = [-1] * n
        cl = 0
        for i in range(n):
            if self.colors[i] == -1:
                self.dfs(graph, i, cl)
                cl += 1

        groups = [0] * cl
        for i in range(n):
            x = self.colors[i]
            groups[x] += 1

        initGroups = [0] * cl
        for node in initial:
            cl = self.colors[node]
            initGroups[cl] += 1

        result = float('inf')
        for node in initial:
            cl = self.colors[node]
            x = initGroups[cl]
            if x == 1:
                if result == float('inf'):
                    result = node
                elif groups[self.colors[node]] == groups[self.colors[result]] and node < result:
                    result = node
                elif groups[self.colors[node]] > groups[self.colors[result]]:
                    result = node

        if result == float('inf'):
            for node in initial:
                result = min(result, node)
        return result

    def dfs(self, graph, i, cl):

        # base
        if self.colors[i] != -1:
            return

        # logic
        self.colors[i] = cl
        for j in range(len(graph)):
            if graph[i][j] == 1:
                self.dfs(graph, j, cl)


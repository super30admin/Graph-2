from collections import deque

class Solution:
    #Solution 1
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        #Approach: DFS // color-coding connected components
        #Time Complexity: O(n^2)
        #Space Complexity: O(n)
        #where, n is the number of nodes in the graph
        
        self.colors = [-1 for _ in graph]     # -1 implies no coding yet
        col = 0
        
        for i in range(len(self.colors)):
            if self.colors[i] == -1:
                self.dfs(i, graph, col)
                col += 1
        
        szCluster = [0 for _ in range(col)]
        for c in self.colors:
            szCluster[c] += 1
            
        initCluster = [0 for _ in range(col)]
        for node in initial:
            initCluster[self.colors[node]] += 1
            
        result = None
        saved = 0
        for node in initial:
            #can only save a cluster if no more than one node is infected
            if initCluster[self.colors[node]] == 1:
                if szCluster[self.colors[node]] > saved:
                    saved = szCluster[self.colors[node]]
                    result = node
                elif szCluster[self.colors[node]] == saved:
                    result = min(result, node)
        
        if not result:
            result = inf
            for node in initial:
                result = min(result, node)
                
        return result
    
    def dfs(self, idx, graph, col):
        #base
        if self.colors[idx] != -1:
            return
        
        #logic
        self.colors[idx] = col
        for j in range(len(graph[idx])):
            if graph[idx][j] == 1:
                self.dfs(j, graph, col)
    
    #Solution 2
    """
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        #Approach: BFS // color-coding connected components
        #Time Complexity: O(n^2)
        #Space Complexity: O(n)
        #where, n is the number of nodes in the graph
        
        colors = [-1 for _ in graph]     # -1 implies no coding yet
        col = 0
        
        for i in range(len(colors)):
            if colors[i] == -1:
                de = deque()
                de.append(i)
                colors[i] = col
                
                while de:
                    popped = de.popleft()
                    for j in range(len(graph[popped])):
                        if graph[popped][j] == 1 and colors[j] == -1:
                            de.append(j)
                            colors[j] = col
                
                col += 1
        
        szCluster = [0 for _ in range(col)]
        for c in colors:
            szCluster[c] += 1
            
        initCluster = [0 for _ in range(col)]
        for node in initial:
            initCluster[colors[node]] += 1
            
        result = None
        saved = 0
        for node in initial:
            #can only save a cluster if no more than one node is infected
            if initCluster[colors[node]] == 1:
                if szCluster[colors[node]] > saved:
                    saved = szCluster[colors[node]]
                    result = node
                elif szCluster[colors[node]] == saved:
                    result = min(result, node)
        
        if not result:
            result = inf
            for node in initial:
                result = min(result, node)
                
        return result
    """
    
    #Solution 3
    """
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        #Approach: DFS -- brute force
        #Time Complexity: O(n^3)
        #Space Complexity: O(n)
        #where, n is the number of nodes in the graph
        
        result = None
        resultLen = inf
        for removedNode in initial:
            self.final = set()
            
            for node in initial:
                if node == removedNode:
                    continue
                
                self.dfs(graph, node)
            
            if len(self.final) < resultLen:
                resultLen = len(self.final)
                result = removedNode
            elif len(self.final) == resultLen and removedNode < result:
                result = removedNode
                
        return result
    
    def dfs(self, graph, node):
        #base
        #not required
        
        #logic
        self.final.add(node)
        for j in range(len(graph[node])):
            if graph[node][j] == 1 and j not in self.final:
                self.dfs(graph, j)
    """
    
    #Solution 4
    """
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        #Approach: BFS -- brute force
        #Time Complexity: O(n^3)
        #Space Complexity: O(n)
        #where, n is the number of nodes in the graph
        
        result = None
        resultLen = inf
        for removedNode in initial:
            final = set()
            
            for node in initial:
                if node == removedNode:
                    continue
                
                de = deque()
                de.append(node)
                final.add(node)
                
                while de:
                    popped = de.popleft()
                    for j in range(len(graph[popped])):
                        if graph[popped][j] == 1 and j not in final:
                            de.append(j)
                            final.add(j)
            
            if len(final) < resultLen:
                resultLen = len(final)
                result = removedNode
            elif len(final) == resultLen and removedNode < result:
                result = removedNode
                
        return result
    """
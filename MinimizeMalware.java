// Time Complexity : O(n^2)
// Space Complexity : O(n)
// Did this code successfully run on Leetcode : Yes
// Any problem you faced while coding this : No


// Your code here along with comments explaining your approach
// Find all the graph components and group their nodes
// Now get the node having component size max and initialInfection count 1
// Return the node having least value which can save max from infection
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        int group = 1;
        
        group = bfs(n, graph, initial, group);
        int[] grpCount = new int[group+1];
        int[] iniInfCount = new int[group+1];
        for(int i = 0; i < n; i++){
            int nodeVal = graph[i][i];
            grpCount[nodeVal]++;
        }
        for(int i = 0; i < initial.length; i++){
            int j = initial[i];
            int groupOf = graph[j][j];
            iniInfCount[groupOf]++;
        }
        int maxSave = -1;
        int initInftoRemove = -1;
        for(int i = 0; i < initial.length; i++){
            int num = initial[i];
            int grp = graph[num][num];
            int count = grpCount[grp];
            int nodesInf = iniInfCount[grp];
            int nodesSaved = (nodesInf == 1)? count : 0;
            if(nodesSaved > maxSave){
                initInftoRemove = num;
                maxSave = nodesSaved;
            }
            else if(nodesSaved == maxSave && initInftoRemove > num){
                initInftoRemove = num;
            }
        }
        return initInftoRemove;
    }
    public int bfs(int n, int[][] graph, int[] intial, int group){
        Queue<Integer> q = new LinkedList<>();
        
        for(int i = 0; i < n; i++){
            if(graph[i][i] == 1){
            group++;
            q.add(i);   
            graph[i][i] = group;
            }
            while(!q.isEmpty()){
                int node = q.poll();
            for(int j = 0; j < n; j++)
            if(graph[node][j] == 1 && graph[j][j] == 1){
                q.add(j);
                graph[j][j] = group;
            }
            }
            
        }
        return group;
    }
}
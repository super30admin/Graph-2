#All TC on leetcode passed

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:

        #Here we create groups for the nodes that are connected by assigning nodes unique color using DFS. We find nodes count in each group, then we compute infected nodes per group. Then we check among the infected nodes which node save more nodes. That is returned as final result.
        #Time complexity - O(n^2) - for dfs
        #Space complexity - O(n) - for node_colors array
        n = len(graph)
        node_colors = [-1]*n
        color = 0
        for i in range(n):
            if node_colors[i]==-1:
                self.dfs(graph, i, node_colors, color, n)
                color+=1

        color_count = color
        groups = [0]*color_count
        infectedNodesPerGroup = [0]*color_count

        #gives nodes in eacg group i.e nodes belonging to each color
        for i in range(n):
            groups[node_colors[i]]+=1
        
        #gives count of infected nodes in each color group
        for i in initial:
            infectedNodesPerGroup[node_colors[i]]+=1

        res = math.inf
        for node in initial:
            c = node_colors[node]
            #if a group has infected nodes more than 1 then dont consider that group as removal of 1 infected node will still cause infection to group
            if infectedNodesPerGroup[c]>1: 
                continue
            if res==math.inf: #initail 1st case
                res = node
            elif groups[node_colors[res]]==groups[c] and node<res: #if equal nodes in both group then take lower index node
                res = node
            elif groups[node_colors[res]]<groups[c]: #if cur node saves more nodes then res is cur node
                res = node
        
        #If no result is found then we return infected node with lowest index
        if res==math.inf:
            for node in initial:
                res = min(res, node)

        return res
    
    def dfs(self, graph, i, node_colors, color, n):
        if node_colors[i]!=-1:
            return
        
        node_colors[i] = color
        for j in range(n):
            if graph[i][j]==1:
                self.dfs(graph, j, node_colors, color, n)
        return
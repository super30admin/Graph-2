// Time Complexity - O(V+E)
// Space Complexity - O(V+E) - Is this correct?
// It runs on Leetcode!
// Problems Faced - No!

class Solution {
    vector<int> markNode;
    private:
    void dfs(vector<vector<int>>& graph, int i, int mark){
        // base
        if(markNode[i] != -1)
            return;
        
        // logic
        markNode[i] = mark;
        for(int j = 0; j < graph.size(); j++){
            if(graph[i][j] == 1){
                dfs(graph, j, mark);
            }
        }
    }
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        markNode.resize(n, -1);
        
        int mark = 0;
        for(int i = 0; i < n; i++){
            if(markNode[i] == -1)
                dfs(graph, i, mark);
            mark++;
        }
        vector<int> numNodesGroup(mark, 0);
        for(int i = 0; i < n; i++){
            int currGroup = markNode[i];
            numNodesGroup[currGroup]++;
        }
        
        vector<int> numInitNodesGroup(mark, 0);
        for(int i = 0; i < initial.size(); i++){
            int currNode = initial[i];
            int currMark = markNode[currNode];
            numInitNodesGroup[currMark]++;
        }
        
        int answer = INT_MAX;
        for(int node : initial){
            int currMark = markNode[node];
            int totalInitInfected = numInitNodesGroup[currMark];
            if(totalInitInfected == 1){
                if(answer == INT_MAX)
                    answer = node;
                else if(numNodesGroup[markNode[answer]] == numNodesGroup[markNode[node]] && node < answer)
                    answer = node;
                else if(numNodesGroup[markNode[answer]] < numNodesGroup[markNode[node]])
                    answer = node;
            }
        }
        
        if(answer == INT_MAX){
            for(int node : initial)
                answer = min(answer, node);
        }
        return answer;
    }
};
//Time Complexity: O(N^2)
//Space Complexity: O(N)
class Solution {
    int n;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        if (graph == null || graph.length == 0) return 0;

        n = graph.length;
        int[] colors = new int[n];
        Arrays.fill(colors, -1);
        int color = 0;

        for (int i=0; i < n; i++) {
            if (colors[i] == -1) {
                dfs(graph, color, colors, i);
                color++;
            }
        }

        int[] groups = new int[color];
        for (int i=0; i<n; i++) {
            int idx = colors[i];
            groups[idx]++;
        }

        int[] initinfected = new int[color];

        for (int i=0; i<initial.length; i++) {
            int idx = colors[initial[i]];
            initinfected[idx]++;
        }

        int answer = Integer.MAX_VALUE;

        for (int i=0; i < initial.length; i++) {
            int col = colors[initial[i]];

            if (initinfected[col] == 1) {
                if (answer == Integer.MAX_VALUE) {
                    answer = initial[i];
                } else if (groups[colors[initial[i]]] > groups[colors[answer]]) {
                    answer = initial[i];
                } else if (groups[colors[initial[i]]] == groups[colors[answer]] && initial[i] < answer) {
                    answer = initial[i];
                }
            }
        }

        if (answer == Integer.MAX_VALUE) {
            int min = Integer.MAX_VALUE;
            for (int i=0; i < initial.length; i++) {
                min = Math.min(min, initial[i]);
            }

            return min;
        }

        return answer;
    }

    private void dfs(int[][] graph, int color, int[] colors, int i) {
        //base
        if (colors[i] != -1) return;

        //logic
        colors[i] = color;
        for (int j=0; j< n; j++) {
            if(graph[i][j] == 1) {
                dfs(graph, color, colors, j);
            }
        }
    }
}
// Time Complexity : O(V+E)
// Space Complexity : O(V+E)
// Did this code successfully run on Leetcode : Yes
// Any problem you faced while coding this : None

public class MinimizeMalwareSpread {
    class Solution {
        int[] colors;
        public int minMalwareSpread(int[][] graph, int[] initial) {
            int n = graph.length;
            this.colors = new int[n];
            Arrays.fill(colors, -1);
            int clr = 0;

            for(int i = 0; i < n; i++){
                if(colors[i] == -1){
                    dfs(graph, i, clr);
                }
                clr++;
            }

            int clrGroup[] = new int[clr];
            int initGroup[] = new int[clr];

            for(int cl : colors){
                clrGroup[cl]++;
            }

            for(int node: initial){
                int cl = colors[node];
                initGroup[cl]++;
            }

            int result = Integer.MAX_VALUE;
            for(int node : initial){
                int cl = colors[node];
                //consider groupf if it has only one malware
                if(initGroup[cl] == 1){
                    if(result == Integer.MAX_VALUE){
                        result = node;
                    }
                    else if(clrGroup[cl] > clrGroup[colors[result]]){
                        result = node;
                    }
                    else if(clrGroup[cl] == clrGroup[colors[result]] && node < result){
                        result = node;
                    }
                }
            }

            //if every n/w has more than 1 malware take the min
            if(result == Integer.MAX_VALUE){
                for(int node : initial){
                    result = Math.min(result, node);
                }
            }
            return result;
        }

        private void dfs(int[][] graph, int i, int cl){
            //base
            if(colors[i] != -1)
                return;
            //logic
            colors[i] = cl;
            for(int j = 0; j < graph.length; j++){
                if(graph[i][j] == 1){
                    dfs(graph, j, cl);
                }
            }

        }
    }
}

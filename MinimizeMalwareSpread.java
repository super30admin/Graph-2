// Time Complexity : O(n^2) --> where n is the length of the graph
// Space Complexity : O(n)
// Did this code successfully run on Leetcode (924): Yes
// Any problem you faced while coding this : No

// Your code here along with comments explaining your approach

class Solution {
    int colors[]; int n;
    
    public int minMalwareSpread(int[][] graph, int[] initial) {
        this.n = graph.length;
        this.colors = new int[n];
        Arrays.fill(colors, -1);
        int c = 0;
    
         // color all the nodes
        for (int i = 0; i < n; i++) {
            if (colors[i] == -1)
            dfs(graph, i, c);
            c++;
        }
        
        // group by color
        int groups[] = new int[c];
        for (int node : colors) {
            groups[node]++;
        }
        
        // see how many malware are affected initially in the group
        int initGroups[] = new int[c];
        for (int node : initial) {
            initGroups[colors[node]]++;
        }
        
        // loop over the initially affected array to get which node should be removed
        int result = Integer.MAX_VALUE;
        for (int node : initial) {
            int cl = colors[node];
            int cnt = initGroups[cl];
            if (cnt == 1) {
                if (result == Integer.MAX_VALUE) result = node;
                // Need to compare how many current node will be able to save in comparision to my already existing
                // result node
                else if (groups[colors[result]] < groups[colors[node]]) result = node;
                else if (groups[colors[result]] == groups[colors[node]] && node < result) result = node;;
            }
        }
        
        if (result == Integer.MAX_VALUE) {
            for (int node : initial) {
                result = Math.min(result, node);
            }
        }
        
        return result;
    }
    
    private void dfs(int[][] graph, int node, int c) {
        // base case
        if (colors[node] != -1) return;
        
        // logic
        colors[node] = c;
        for (int j = 0; j < n; j++) {
            if (graph[node][j] == 1) {
                dfs(graph, j, c);
            }
        }
    }
}
import java.util.Arrays;

// Time Complexity : O(V*V) where V = number of node, E = number of edges
// Space Complexity : O(n) where n = number of nodes
// Did this code successfully run on Leetcode :
// Any problem you faced while coding this :

// Your code here along with comments explaining your approach
//924. Minimize Malware Spread (Hard) - https://leetcode.com/problems/minimize-malware-spread/
// Time Complexity : O(V*V) where V = number of node, E = number of edges
// Space Complexity : O(n) where n = number of nodes
class Solution {

	int[] colors;

	public int minMalwareSpread(int[][] graph, int[] initial) {
		int n = graph.length;
		colors = new int[n];
		Arrays.fill(colors, -1);

		int color = 0;

		// fill each node with a color that belongs to same group
		for (int i = 0; i < n; i++) { // O(n*n)
			if (colors[i] == -1) {
				dfs(graph, i, color);
				color++;
			}
		}

		int[] nodeCountInGroup = new int[color]; // number of groups == number of colors assigned

		for (int i = 0; i < n; i++) {
			int colour = colors[i];
			nodeCountInGroup[colour]++;
		}

		int[] infectedNodesInGroup = new int[color]; // number of groups == number of colors assigned

		for (int node : initial) {
			int colour = colors[node];
			infectedNodesInGroup[colour]++;
		}

		int result = Integer.MAX_VALUE;

		for (int node : initial) {
			int colour = colors[node];

			if (infectedNodesInGroup[colour] == 1) {
				if (result == Integer.MAX_VALUE) {
					result = node;
				} else if (nodeCountInGroup[colour] > nodeCountInGroup[colors[result]]) {
					result = node;
				} else if (nodeCountInGroup[colour] == nodeCountInGroup[colors[result]] && node < result) {
					result = node;
				}
			}
		}

		if (result == Integer.MAX_VALUE) {
			for (int node : initial) {
				result = Math.min(result, node);
			}
		}

		return result;
	}

	private void dfs(int[][] graph, int i, int color) {
		// base
		if (colors[i] != -1)
			return;

		// logic
		colors[i] = color;
		for (int j = 0; j < graph.length; j++) {
			if (graph[i][j] == 1) {
				dfs(graph, j, color);
			}
		}
	}
}
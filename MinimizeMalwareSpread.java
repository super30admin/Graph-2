class Solution {

    // Time Complexity : 0(n^2) where n is the length of graph
// Space Complexity : 0(n)
// Did this code successfully run on Leetcode : Yes
// Any problem you faced while coding this : No


// Your code here along with comments explaining your approach


    int n;  //length of graph
    int [] colors;  //to give colors to different froups of servers and create a color array with the no. of servers that exist. The indexes are the servers and value is the color assigned to them
    public int minMalwareSpread(int[][] graph, int[] initial) {
        if(graph == null || graph.length == 0 ){
            return 0;
        }

        n = graph.length;
        colors = new int[n];
        Arrays.fill(colors, -1);    //initially filling it with -1 so that we don't recolor a server again and again
        int c = 0;  //to assign different colors to different groups

        for(int i = 0; i < n; i++){
            if(colors[i] == -1){    //filling colors
                dfs(graph, i, c);
                c++;    //when 1 color is assigned to a group of servers, increasing the color
            }
        }

        int[] groups = new int[c];  //to calculate the no. of servers in each color

        for(int i = 0; i < n; i++){
            int color = colors[i];  //getting the color of the server
            groups[color]++;    //increasing the no. of server in the group array
        }

        int[] infected = new int[c];    //to get the total infected servers in each group

        for(int i = 0; i < initial.length; i++){
            int color = colors[initial[i]]; //getting the infected server
            infected[color]++;  //increasing the value of the infected group
        }

        int ans = Integer.MAX_VALUE;    //initially ans will hold the max value

        for(int i = 0; i < initial.length; i++){    //going over the infected nodes
            int color = colors[initial[i]]; //getting the icolor of the infected node
            if(infected[color] == 1){   //now checking if there is 1 infected node for that group or not
                if(ans == Integer.MAX_VALUE){   //if ans is not yet initialize, then initializing it to the node that is infected
                    ans = initial[i];
                }
                else if(groups[colors[ans]] < groups[color]){   //if there answer is initialized and then I find that there is a group that has more servers that can be saved
                    ans = initial[i];   //then storing my new answer as that infected node
                }
                else if(groups[colors[ans]] == groups[color] && initial[i] < ans){  //if there are 2 groups with same servers and there is a better node at a beginning position
                    ans = initial[i];   //then i save that server
                }
            }
        }

        if(ans == Integer.MAX_VALUE){   //if there is no server I can save, meaning there are atleast 2 infected nodes in each server
            for(int i = 0; i < initial.length; i++){    //I select the minimum among them
                ans = Math.min(ans, initial[i]);
            }
        }
        return ans;
    }

    public void dfs(int [][] graph, int i, int c){  //to assign color to each group or each row of servers
        if(colors[i] != -1){    //if it is seen, I return
            return;
        }
        colors[i] = c;  //filling the color
        for(int j = 0; j < n; j++){
            if(graph[i][j] == 1){   //if the graph value is 1, means it is connected and adding the color to that server
                dfs(graph, j, c);
            }
        }
    }
}
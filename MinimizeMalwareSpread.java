// Time Complexity: O(N^2)
// Space Complexity: O(N)

class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        
        int n = graph.length;

        int[] color = new int[n];
        Arrays.fill(color, -1);

        int currentColor = 0;

        for(int u = 0; u < n; u++) {
        	if(color[u] == -1) {
        		dfsVisit(graph, color, u, currentColor);
        		currentColor++;
        	}
        }

        // numComponents = currentColor

        int[] componentSize = new int[currentColor];
        
        for(int u = 0; u < n; u++) {
        	componentSize[color[u]]++;
        }

        // count of infected node in component
        int[] countInfectedNodes = new int[currentColor];
        for(int u: initial) {
        	countInfectedNodes[color[u]]++;
        }

        int cureIndex = Integer.MAX_VALUE;

        for(int node: initial) {
        	if(countInfectedNodes[color[node]] == -1) {
        		if(cureIndex == Integer.MAX_VALUE) {
        			cureIndex = node;
        		} else if(componentSize[color[node]] > componentSize[color[cureIndex]]) {
        			cureIndex = node;
        		} else if(componentSize[color[node]] == componentSize[color[cureIndex]]) {
        			cureIndex = Math.min(cureIndex, node);
        		}
        	}
        }

        if(cureIndex == Integer.MAX_VALUE) {
        	for(int u: initial) {
        		cureIndex = Math.min(u, cureIndex);
        	}
        }

        return cureIndex;
    }

    private void dfsVisit(int[][] graph, int[] color, int u, int currentColor) {
    	color[u] = currentColor;
    	for(int v = 0; v < graph.length; v++) {
    		if(color[v] == -1 && graph[u][v] == 1) {
    			dfsVisit(graph, color, v, currentColor);
    		}
    	}
    }
}
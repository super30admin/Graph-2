import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

/*
Time complexity: O(V+E), V is the number of vertices and E is the edges
Space Complexity: O(V^2), V is the number of vertices
Run on leetcode: yes
Any difficulties: No

Approach:
1. Assigning each node a group and then checking group node counts
2. If a group has more than one node which is infected, one can not rescue that group
3. Using Breadth First Search to traverse over the graph
 */
public class MinimizeMalwareSpread {
    public static int minimumMalware(int[][] graph, int[] initial){
        int n = graph.length;
        int[] groupOfNodes = new int[n];
        int groups = 0;

        Arrays.fill(groupOfNodes, -1);

        for(int i = 0; i<n; i++){
            if(groupOfNodes[i] == -1){
                traverseOnTheGraph(graph, i, groupOfNodes, groups);
                groups++;
            }
        }
        int[] groupNodeCount = new int[groups];

        for(int i = 0; i<n; i++){
            int groupNumber = groupOfNodes[i];
            groupNodeCount[groupNumber]++;
        }

        int[] infectedNodes = new int[groups];

        for(int initialNode: initial){
            int groupNumber = groupOfNodes[initialNode];
            infectedNodes[groupNumber]++;
        }

        int maxSafeNodes = Integer.MIN_VALUE;
        int remainingNodes = -1;

        for(int initialNode: initial){
            int groupNumber = groupOfNodes[initialNode];
            int totalNumberOfNode = groupNodeCount[groupNumber];
            int infectedNode = infectedNodes[groupNumber];

            int safeNodes = infectedNode == 1? totalNumberOfNode: 0;

            if(safeNodes>maxSafeNodes){
                maxSafeNodes = safeNodes;
                remainingNodes = initialNode;
            }else if(safeNodes==maxSafeNodes && initialNode <remainingNodes){
                remainingNodes = initialNode;
            }
        }
        return remainingNodes;
    }
    public static void traverseOnTheGraph(int[][] graph, int node, int[] groupOfNodes, int groupNumber){
        Queue<Integer> queue = new LinkedList<>();

        queue.add(node);

        groupOfNodes[node] = groupNumber;

        while(!queue.isEmpty()){
            node = queue.remove();
            for(int i =0; i<graph.length; i++){
                if(graph[node][i] ==1 && groupOfNodes[i] == -1){
                    queue.add(i);
                    groupOfNodes[i] = groupNumber;
                }
            }
        }
    }
}

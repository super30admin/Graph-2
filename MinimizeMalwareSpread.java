// 942.
// time - O(n^2) - graph is an adjacency matrix
// space - O(n)

// example graph
//   * *
// 1-2-3-4     * marks infected nodes

//   *         list of infected nodes = [2,3,6,9]
// 5-6-7        if node 6 is made healthy, then 3 nodes(5,6,7) can be saved
    
//   *          if node 9 is made healthy, then 2 nodes(8,9) can be saved
// 8-9          making 1 or 2 healthy cant save any nodes

//if 8-9-10 has 9 infected, changing 6 and 9 will save same amount of nodes , so return min (6)
//if 1 more node was infected in both the other comonents, each compononet would have had same # of infected nodes, changing any node wont save anything
//in that case too return min node that is infected

// approach - color nodes such that all nodes in a component have same colour -> toltal # of connected components = # of colors
// find number of nodes in each color
// find number of infected nodes in each color

//for the above graph
// colors = [0,0,0,0,1,1,1,2,2]
// groups = [4,3,2] - size is # of colors
// infected = [2,1,1] - size is # of colors

//iterated thru each infected node in i/p list, if it is the only infected node in that group, make it healthy and save other nodes in that group, find max for each infected node

class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int[] colors = new int[graph.length]; //graph is adjacency matrix
        Arrays.fill(colors, -1); //colors[] filled with -1s - serves as visited[] too
        int color = 0;
        for(int i = 0; i < graph.length; i++)
        {
            if(colors[i] == -1) //if node is not processed, color it by calling dfs()
            {
                dfs(i, graph, color, colors);
                color++; //for the next component diff color is given
            }
        }
        
        int[] groups = new int[color]; //# of groups = # of diff colors assigned
        for(int i = 0; i < colors.length; i++)
        {
            int currentColor = colors[i];
            groups[currentColor] += 1; //increament the count of current group by 1
        }
        
        int[] infected = new int[color]; //# of groups = # of diff colors assigned
        for(int i = 0; i < initial.length; i++)
        {
            int infectedColor = colors[initial[i]]; //get the color of current infected node
            infected[infectedColor] += 1; //increament the count of current group by 1
        }
        
        Integer savedNode = null; //node that is made healthy
        Integer maxNodesSaved = null; //number of nodes saved by making saved node healthy
        
        //go through each infected node
        for(int infectedNode : initial)
        {
            //find the # of infected nodes in this group
            int infectedColor = colors[infectedNode]; //get the color of current infected node
            int numberOfInfectedNodesInCurrentGroup = infected[infectedColor];
            if(numberOfInfectedNodesInCurrentGroup == 1)
            {
                //number of infected nodes in current group is 1
                //so make it healthy and save all nodes in this group
                if(maxNodesSaved == null || groups[infectedColor] > maxNodesSaved)
                {
                    maxNodesSaved = groups[infectedColor];
                    savedNode = infectedNode;
                }
                else if(groups[infectedColor] == maxNodesSaved && infectedNode < savedNode)
                {
                    savedNode = infectedNode;
                }
            }
        }
        
        if(savedNode == null) //there were no groups in which only one node was infected - return smallest infected node
        {
            savedNode = initial[0];
            for(int i = 1; i < initial.length; i++)
            {
                savedNode = Math.min(savedNode, initial[i]);
            }
        }
        
        return savedNode;
    }
    
    //time - O(n^2) - since g is an adjacency matrix
    //space - O(n) - max call stack size when a node is connected to all other nodes
    private void dfs(int node, int[][] graph, int color, int[] colors) {
        //base
        if(colors[node] != -1)
        {
            return; //incoming node already processed
        }
        //logic
        colors[node] = color; //marking as visited and providing color to this node
        //recurse on neighbors
        for(int i = 0; i < graph[0].length; i++)
        {
            if(graph[node][i] == 1)
            {
                //node i is neighbor of current since graph[current][i] = 1
                dfs(i, graph, color, colors);
            }
        }
        return;
    }
}

// Time Complexity : O (N^2)
// Space Complexity : O(n)
// Did this code successfully run on Leetcode : Yes
// Any problem you faced while coding this :

// Your code here along with comments explaining your approach
class Solution {
    
    private int[] colors;
    private int n;
    
    public int minMalwareSpread(int[][] graph, int[] initial) {
        n = graph.length;
        colors = new int[n];
        
        Arrays.fill(colors, -1);
        int curr_color = 0;
        
        for(int i=0; i<n; i++){
            if(colors[i]==-1){
                dfs(i, graph, curr_color);
            }
            curr_color++;
        }
        //create groups
        int groups[] = new int[curr_color];
        for(int color: colors){
            groups[color]++;
        }
        
        //create affected
        int[] affected = new int[curr_color];
        for(int init: initial){
            affected[colors[init]]++;
        }
        
        int result = Integer.MAX_VALUE;
        
        for(int init : initial){
            int color = colors[init];
            if(affected[color]==1){
                if(result == Integer.MAX_VALUE){
                    result = init;
                }else if(groups[color]>groups[colors[result]]){ // Breaking tie between one group > other
                    result = init;
                }else if(groups[color]== groups[colors[result]] && result > init){
                    result = init;
                }
            }
        }
        
        if(result== Integer.MAX_VALUE){
            for(int init : initial){
                result = Math.min(result, init);
            }
        }
        
        return result;
        
    }
    
    private void dfs(int i, int[][] graph, int curr_color){
        colors[i] = curr_color;
        
        for(int j=0; j<n; j++){
            if(graph[i][j] ==1 && colors[j] == -1){
                dfs(j, graph, curr_color);
            }
        }
    }
}

/// TC: O(N*N) -> N : graph.length ( no. of nodes)
// SC: O(N)
// Did it run successfully on Leetcode? : Yes
class Solution {
    int[] colorCodes;
    int n;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        if (graph == null || graph.length == 0)
            return 0;
        n = graph.length; // n -> no. of nodes
        colorCodes = new int[n];
        int color = 0;
        Arrays.fill(colorCodes, -1);
        
        //O(N*N)
        for ( int i = 0; i < n; i++) //O(N)
        {
            if (colorCodes[i] == -1)
                 dfs(i, graph, color); //O(N)
                 color++;
        }
      
        int[] groups = new int[color];          // groups = colorCount of each color
        for (int c : colorCodes)
        {
            groups[c]++;
        }
        // System.out.println("groups = " + groups);
        
        int[] initialGroups = new int[color]; // how many unique colors in each group
        
        for (int node : initial)
        {
            initialGroups[colorCodes[node]]++;
        }
        int result = Integer.MAX_VALUE;
        for (int node : initial)
        {
            // how many nodes are affected initially in th group belonging to this node
            int count = initialGroups[colorCodes[node]];
            if (count == 1)
            {
                if(result == Integer.MAX_VALUE)
                {
                    result = node;
                }
                else if (groups[colorCodes[result]] < groups[colorCodes[node]])
                {
                    result = node;
                }
                else if (groups[colorCodes[result]] == groups[colorCodes[node]] && node < result)
                {
                    result = node;
                } 
            }
        }
        if (result == Integer.MAX_VALUE) 
        {
            for (int node: initial)
            {
                result = Math.min(result, node);
            }
        }
        return result;
    }
    private void dfs(int node, int[][] graph, int c )
    {
        //base
        if (colorCodes[node] != -1)
            return;
        
        //logic
        colorCodes[node] = c;
        for ( int j = 0; j < n; j++)
        {
                if ( graph[node][j] == 1)
                   dfs(j, graph, c);
            }
        }
    }


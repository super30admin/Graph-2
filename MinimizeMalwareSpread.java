//Time Complexity : O(N^2)
//Space Complexity : O(N)
//Did this code successfully run on Leetcode : Yes
//Any problem you faced while coding this : No


/**
 * Use union find to merge all components that can be merged together and then
 * iterate over the initial array to find the minimum value.
 *
 */
class Solution {
	int[] parents;
	int[] size;

	public int minMalwareSpread(int[][] graph, int[] initial) {
		int n = graph.length;
		parents = new int[n];
		size = new int[n];

		for (int i = 0; i < n; i++) {
			parents[i] = i;
			size[i] = 1;
		}

		for (int i = 0; i < n; i++) {
			for (int j = i + 1; j < n; j++) {
				if (graph[i][j] == 1)
					union(i, j);
			}
		}

		int[] infected = new int[n];
		for (int in : initial)
			infected[find(in)]++;

		int maxSize = 0;
		int bestMalware = -1;
		for (int in : initial) {
			int root = find(in);
			if (infected[root] > 1)
				continue;
			if (size[root] > maxSize) {
				maxSize = size[root];
				bestMalware = in;
			} else if (size[root] == maxSize && in < bestMalware)
				bestMalware = in;
		}

		if (bestMalware == -1) {
			bestMalware = n;
			for (int node : initial)
				bestMalware = Math.min(bestMalware, node);
		}

		return bestMalware;
	}

	private void union(int u, int v) {
		int pu = find(u);
		int pv = find(v);
		if (pu == pv)
			return;

		if (size[pu] >= size[pv]) {
			parents[pv] = pu;
			size[pu] += size[pv];
		} else {
			parents[pu] = pv;
			size[pv] += size[pu];
		}
	}

	private int find(int a) {
		if (parents[a] == a)
			return a;

		return parents[a] = find(parents[a]);
	}
}

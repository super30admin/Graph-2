class MinimizeMalwareSpread {
    
    // Time Complexity: O(n^2)
    // Space Complexity: O(n)
    
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        int[] colors = new int[n];
        Arrays.fill(colors, -1);
        
        int color = 0;
        for(int i = 0; i < n; i++){
            if(colors[i] == -1)
                dfs(i, colors, graph, color);
            color++;
        }
        
        int[] group = new int[color];
        for(int c : colors)
            group[c]++;
        
        int[] affected = new int[color];
        for(int i : initial)
            affected[colors[i]]++;
        
        int result = Integer.MAX_VALUE;
        for(int i : initial){
            int c = colors[i];
            int g = group[c];
            int a = affected[c];
            
            if(a == 1){
                if(result == Integer.MAX_VALUE)
                    result = i;
                else if(g > group[colors[result]])
                    result = i;
                else if(g == group[colors[result]] && result > i)
                    result = i;
            }
        }
        
        if(result == Integer.MAX_VALUE){
            for(int i : initial)
                result = Math.min(result, i);
        }
        
        return result;
    }
    
    private void dfs(int node, int[] colors, int[][] graph, int color){
        colors[node] = color;
        
        // traverse through the neighbors of the current node
        for(int v = 0; v < graph.length; v++){
            int edge = graph[node][v];
            if(edge == 1 && colors[v] == -1)
                dfs(v, colors, graph, color);
        }
    }
}
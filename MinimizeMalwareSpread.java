// Time Complexity : O(n ^ 2)
// Space Complexity : O(n)

class Solution {
    int[] color; 
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        color = new int[n];
        Arrays.fill(color, - 1);
        int clr = 0 ;
        for(int i = 0; i < n; i++){
            if(color[i] == -1){
                dfs(graph, i, clr, n);
                clr++;
            }
        }
        
        int[] group = new int[clr];
        for(int i = 0; i < n; i++){
           group[color[i]]++;
        }
        
        int[] initialGroups = new int[clr];
        
        for(int node: initial){
            int c = color[node];
            initialGroups[c]++;
        }
        
        int res = Integer.MAX_VALUE;
        
         for(int node: initial){
            if(initialGroups[color[node]] == 1){
                if(res == Integer.MAX_VALUE){
                    res = node;
                }
                else if(group[color[node]] > group[color[res]])
                    res = node;
                else if(group[color[node]] == group[color[res]] && node < res)
                    res = node;
            }
        }
        
        if(res == Integer.MAX_VALUE){
            for(int node: initial)
                res = Math.min(res, node);
        }
        
        return res;
    }
    
    private void dfs(int[][] graph, int i, int clr, int n){
        //base
        if(color[i] != -1)
            return;
        //logic
        color[i] = clr;
        for(int j = 0; j < n; j++){
            if(graph[i][j] == 1)
                dfs(graph, j, clr, n);
        }
    }
}
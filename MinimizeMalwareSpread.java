// Time Complexity : O(n^2)
// Space Complexity : O(n)
// Did this code successfully run on Leetcode : Yes

import java.util.Arrays;

public class MinimizeMalwareSpread {

    int n;
    int[] clusters;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        n = graph.length;
        clusters = new int[n];
        int clusterCount = 0;
        Arrays.fill(clusters,-1);

        for(int i=0; i<n; i++){             //O(n^2)
            if(clusters[i] == -1){
                dfs(graph,i,clusterCount);
                clusterCount++;
            }
        }

        int[] group = new int[clusterCount];

        for(int node:clusters){   // number of nodes in each group  //O(n)
            group[node]++;
        }

        int[] initArr = new int[clusterCount];
        for(int node: initial){    // number of affected in each group  //<<<<<n
            initArr[clusters[node]]++;
        }

        int result = Integer.MAX_VALUE;

        for(int node : initial){                //<<<<<n
            int cnt = initArr[clusters[node]];
            if(cnt == 1){
                int numbersOfNodes = group[clusters[node]];
                if(result == Integer.MAX_VALUE){
                    result = node;
                }else if(group[clusters[result]] < numbersOfNodes){
                    result = node;
                }else if(group[clusters[result]] == numbersOfNodes){
                    result = Math.min(result,node);
                }
            }
        }

        if(result == Integer.MAX_VALUE){
            for(int node: initial)
                result = Math.min(result,node);
        }
        return result;
    }

    private void dfs(int[][] graph, int i, int clusterCount){

        if(clusters[i] != -1) return;

        clusters[i] = clusterCount;
        for(int j=0; j<n; j++){
            if(i == j) continue;
            if(graph[i][j] == 1)
                dfs(graph,j,clusterCount);
        }
    }
}


import java.util.Arrays;

//Time Complexity : O(n^2)
//Space Complexity : O(n)
public class MinimizeMalwareSpread { 
	/**Approach: DFS**/
	public int minMalwareSpread(int[][] graph, int[] initial) {
        int n= graph.length;
        int[] colors = new int[n];
        Arrays.fill(colors, -1);        
        //prepare colors array by calling DFS
        int col = 0;
        for(int i=0; i<n; i++){
            if(colors[i] == -1){
                dfs(graph, colors, i, col);
                col++;
            }
        }        
        //prepare groups to see how many nodes are there in each group/color.
        int[] groups = new int[col];
        for(int color: colors){            
            groups[color]++;
        }        
        //prepare initial groups to see how many infected nodes are there in each group
        int[] initialGroups = new int[col];
        for(int i : initial){
            int color = colors[i];
            initialGroups[color]++;
        }        
        //Check if any of the group has just 1 infected node then it can be potential group from which node to be removed.
        int result = -1;
        for(int i : initial){
            int color = colors[i];
            int infected = initialGroups[color];
            if(infected == 1){ 
            	//Assign current node as result If,
            	//it is the first candidate which can save some node or,
            	//current node savings are more than earlier one or,
            	//current node savings are same as the earlier one and index is smaller.
                if(result == -1 
                	|| (groups[color] > groups[colors[result]])
                	|| (groups[color] == groups[colors[result]] && i < result)){  
                    result = i;
                }
            }
        }        
        //If multiple/no nodes to be removed. Get smallest index from initial.
        if(result == -1){
            result = initial[0];
            for(int i : initial){
                result = Math.min(result, i);
            }
        }
        return result;
    }
    private void dfs(int[][] graph, int[] colors, int i, int color){
        //base
        if(colors[i] != -1) return;
        //logic
        colors[i] = color;
        for(int j=0; j<colors.length; j++){
            if(graph[i][j] == 1){
                dfs(graph, colors, j, color);
            }
        }
    }
	 
    
	// Driver code to test above
	public static void main (String[] args) {	
		MinimizeMalwareSpread ob  = new MinimizeMalwareSpread();			
		int[][] graph = {{1,0,0},{0,1,0},{0,0,1}};//{{1,1,0},{1,1,0},{0,0,1}};
		int[] initial = {0,2};//{0,1};
		System.out.println("Node to be removed to minimize the malware spread : "+ob.minMalwareSpread(graph, initial));
	}
}

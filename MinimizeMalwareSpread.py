"""
Rasika Sasturkar
Using DFS -
Time Complexity: O(n^2), n is no. of nodes in graph
Space Complexity: O(n)
"""

import math


def minMalwareSpread(graph, initial) -> int:
    # null case
    if graph is None:
        return -1

    n = len(graph)
    colors = [-1 for _ in range(n)]
    clr = 0  # color variable

    def dfs(graph, i, clr):
        # base case
        if colors[i] != -1:
            return

        # logic
        colors[i] = clr
        for j in range(len(graph)):
            if graph[i][j] == 1:
                dfs(graph, j, clr)

    for i in range(n):
        if colors[i] == -1:
            dfs(graph, i, clr)
        clr += 1

    groups = [0 for _ in range(clr)]
    for i in range(n):
        c = colors[i]
        groups[c] += 1

    total_init_infected = [0 for _ in range(clr)]
    for node in initial:
        c = colors[node]
        total_init_infected[c] += 1

    result = math.inf
    for node in initial:
        c = colors[node]
        cnt = total_init_infected[c]
        if cnt == 1:
            if result == math.inf:
                result = node
            elif groups[colors[result]] == groups[colors[node]] and node < result:
                result = node
            elif groups[colors[result]] < groups[colors[node]]:
                result = node

    if result == math.inf:
        for node in initial:
            result = min(result, node)

    return result


def main():
    """
    Main function - examples from LeetCode problem to show the working.
    This code ran successfully on LeetCode and passed all the test cases.
    """
    print(minMalwareSpread(graph=[[1, 1, 0], [1, 1, 0], [0, 0, 1]], initial=[0, 1]))  # returns 0
    print(minMalwareSpread(graph=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], initial=[0, 2]))  # returns 0
    print(minMalwareSpread(graph=[[1, 1, 1], [1, 1, 1], [1, 1, 1]], initial=[1, 2]))  # returns 1


if __name__ == "__main__":
    main()

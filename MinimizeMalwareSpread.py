"""
Time Complexity : O(V^2) - N is the size of the graph
Space Complexity : O(V)- stack space plus arrays
Did this code successfully run on Leetcode : Yes
Any problem you faced while coding this : No
Your code here along with comments explaining your approach:
For this question, we have certain preprocessing to follow. 
First of all, we need to do DFS over the matrix to find out which nodes are together. To do so, we can color the nodes in same color, if they are together. Secondly, we nee to make a list which
stores oinformation regarding number of nodes inside a particular colored group. 
Thereafter, we need to make another list which has info of how many nodes are infeted in all the groups. 
Then we will traverse over the initial infected array, check in which group they are, how many infected servers in that group. If its more than 1, we basically need to ignore it. If it becomes 1 for the
first time, we record the node's details. 
If the number of node is 1 and we already have 1,we will check which one has more nodes
to save, we would take that value. If number of nodes are also same, we would take the minimum.  
In case, after we iterate through everything and we find that there is no group with 1 infected server,
we can return the node number with least value.
"""

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        
        N = len(graph)
        colors = [-1]*N
        
        C=0
        
        # Coloring the node
        for node in range(N):
            if colors[node] == -1:
                self.dfs(graph,colors,node,C)
                C+=1
                
        # Size of each component
        size = [0] * C
        
        for color in colors:
            size[color]+=1
            
        # Count infected node in each component
        colorCount = [0]*C
        for node in initial:
            colorCount[colors[node]]+=1
                
        # Find the solution
        ans = float("inf")
        for node in initial:
            c=colors[node]
            if colorCount[c]==1:
                
                if ans == float("inf"):
                    ans = node
                elif size[c]>size[colors[ans]]:
                    ans = node
                elif size[c] == size[colors[ans]] and node<ans:
                    ans = node
                    
        if ans == float("inf"):
            for node in initial:
                ans = min(node,ans)
                
        return ans
            
                
    def dfs(self,graph,colors,node,color):
        
        colors[node]=color
        for neighbor in range(0,len(graph)):
            if graph[node][neighbor] == 1 and colors[neighbor] == -1:
                self.dfs(graph,colors,neighbor,color)
                
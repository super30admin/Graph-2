import java.util.Scanner;
import java.util.Arrays;

public class MinimizeMalwareSpreadDFS {

        // DFS - Time O(n*n) and Space O(n)

        // global
        int n;
        int[] colors;

        public int minMalwareSpread(int[][] graph, int[] initial) {

            //
            n = graph.length;
            this.colors = new int[n];   // O(n) space

            Arrays.fill(colors, -1);

            int c = 0;

            // color allocation to nodes
            for(int i = 0; i < n; i++) {     // O(n*n)

                // if unvisited
                if(colors[i] == -1) {

                    // all connected nodes will get same color number
                    dfs(graph, i, c);
                }

                // increment color number
                c++;
            }

            // grouping nodes based on color
            int[] groups = new int[c];

            for(int i = 0; i < n; i++) {    // O(n)

                //
                int color = colors[i];

                groups[color]++;
            }

            // initially malware infected node group
            int[] malGroup = new int[c];

            for(int malNode: initial) {      // O(n)

                // infected node color
                int malColor = colors[malNode];

                malGroup[malColor]++;
            }

            //
            int result = Integer.MAX_VALUE;

            // iterate over initial
            for(int malNode: initial) {       // O(n)

                int malColor = colors[malNode];

                // only if malware nodes in a group is one and not more than one
                if(malGroup[malColor] == 1) {

                    //
                    if(result == Integer.MAX_VALUE) {

                        result = malNode;
                    }

                    // if current mal Node saves more nodes in a color group than the previous result, update result
                    if(groups[colors[result]] < groups[colors[malNode]]) {

                        result = malNode;
                    }

                    // if multiple nodes could be removed to minimize M(initial), return such a node with the smallest index
                    if(groups[colors[result]] == groups[colors[malNode]]
                            && malNode < result ) {

                        result = malNode;
                    }
                }
            }

            // if no removable node found above
            if(result == Integer.MAX_VALUE) {

                // iterate over initial again and take the smallest index node
                for(int malNode: initial) {

                    result = Math.min(result, malNode);
                }
            }

            // output
            return result;
        }

        // dfs method to find connected components of color
        public void dfs(int[][] graph, int node, int color) {

            //base
            if(colors[node] != -1) {
                //
                return;
            }

            //logic
            //action
            colors[node] = color;

            //recursion
            for(int i = 0; i < n; i++) {

                //
                if(graph[node][i] == 1) {

                    //
                    dfs(graph, i, color);
                }
            }

        }

        public static void main(String[] args) {

            MinimizeMalwareSpreadDFS obj = new MinimizeMalwareSpreadDFS();

            Scanner scanner = new Scanner(System.in);

            System.out.println("number of nodes: ");
            int n = scanner.nextInt();

            int[][] graph = new int[n][n];

            System.out.println("graph: ");
            for(int i = 0; i < n; i++) {
                System.out.println("row " + (i+1));
                for(int j = 0; j < n; j++) {
                    graph[i][j] = scanner.nextInt();
                }
            }

            System.out.println("number of initially infected nodes by malware: ");
            int m = scanner.nextInt();
            int[] initial = new int[m];

            System.out.println("initial: ");
            for(int i = 0; i < m; i++) {

                initial[i] = scanner.nextInt();
            }

            int answer = obj.minMalwareSpread(graph, initial);

            System.out.println("the node that, if removed, would minimize the final number of nodes " +
                    "infected with malware in the entire network after the spread of malware stops is " + answer);
        }
}

/*
Time Complexity = O(n*n)
Space Complexity = O(n)
*/
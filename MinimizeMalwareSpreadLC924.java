class Solution {

    //Approach 2
    //Time Complexity: O(n*n)
    //Space Complexity: O(n)

    int[] colors;

    public int minMalwareSpread(int[][] graph, int[] initial) {

        if(graph == null || graph.length == 0) return -1;           //check for null case

        int n = graph.length;                           //store the graph length

        colors = new int[n];                            //create an array to store which node belongs to which color(means which group)
        Arrays.fill(colors, -1);                       //O(n) //fill colors array with -1

        int color = 0;                                  //create a color variable to give different colors to different group

        //here we are only doing dfs on that groups which has at least one infected node as these are the only groups that are useful for the result

        for(int node: initial){                        //O(n*n) //iterate through infected array

            if(colors[node] == -1){                        //check if that node is not assigned any colors yet
                dfs(graph, node, color);                   //if so, then call the dfs function on that node
            }
            color++;                                    //means, we colored one group, so increament the color value
        }

        int[] groups = new int[color];                      //create a group array to store the total groups and each groups how many nodes are there

        int[] infectedNodesInGroup = new int[color];        //create an array to store in each group how many nodes are infected

        for(int i=0; i<n; i++){                         //iterate through colors array

            if(colors[i] == -1) continue;                //check if any node haven't assigned colors(means that node belongs to that group which isn't have any infected node) then skip that node

            groups[colors[i]]++;                        //take the color of that node(means which group that node belongs) and increament the counter for that group
        }

        for(int node: initial){                         //iterate through the infected array
            infectedNodesInGroup[colors[node]]++;           //take the color of that infected node(means which group that node belongs) and incremented the counter for the infectedNodesInGroup counter
        }

        int result = Integer.MAX_VALUE;                 //create a result variable to store the result node

        for(int node: initial){                                     //iterate through infected array

            if(infectedNodesInGroup[colors[node]] == 1){               //take the colors of that node(means which group that node belongs) and check if that node has only 1 node infected

                if(result == Integer.MAX_VALUE){                    //if so, then check if result is Integer.MAX_VALUE
                    result = node;                                  //if so, then update the result value
                }
                else if(groups[colors[result]] == groups[colors[node]] && node < result){           //check if the totalNodes in group which has the result node is equal to the totalNodes in group which has the node and if node < result
                    result = node;                                                  //then update the result
                }
                else if(groups[colors[result]] < groups[colors[node]]){                     //check if the totalNodes in group which has the result node is less than to the totalNodes in group which has the node
                    result = node;                                  //then update the node
                }
            }
        }

        if(result == Integer.MAX_VALUE){                            //check if result is still Integer.MAX_VALUE means we can't cut any node inorder to save the maximum nodes from malware
            for(int node: initial){                                     //if so, then iterate the infected node and return the least number node
                result = Math.min(node, result);
            }
        }
        return result;                                          //return the result
    }





    //Approach 1
    //Time Complexity: O(n*n)
    //Space Complexity: O(n)

    // int[] colors;

    // public int minMalwareSpread(int[][] graph, int[] initial) {

    //     if(graph == null || graph.length == 0) return -1;           //check for null case

    //     int n = graph.length;                           //store the graph length

    //     colors = new int[n];                            //create an array to store which node belongs to which color(means which group)
    //     Arrays.fill(colors, -1);                        //fill colors array with -1

    //     int color = 0;                                  //create a color variable to give different colors to different group

    //     for(int i=0; i<n; i++){                       //O(n*n)  //iterate through colors array

    //         if(colors[i] == -1){                        //check if that node is not assigned any colors yet
    //             dfs(graph, i, color);                   //if so, then call the dfs function on that node
    //         }
    //         color++;                                    //means, we colored one group, so increament the color value
    //     }

    //     int[] groups = new int[color];                      //create a group array to store the total groups and each groups how many nodes are there

    //     int[] infectedNodesInGroup = new int[color];        //create an array to store in each group how many nodes are infected

    //     for(int i=0; i<n; i++){                         //iterate through colors array
    //         groups[colors[i]]++;                        //take the color of that node(means which group that node belongs) and increament the counter for that group
    //     }

    //     for(int node: initial){                         //iterate through the infected array
    //         infectedNodesInGroup[colors[node]]++;           //take the color of that infected node(means which group that node belongs) and incremented the counter for the infectedNodesInGroup counter
    //     }

    //     int result = Integer.MAX_VALUE;                 //create a result variable to store the result node

    //     for(int node: initial){                                     //iterate through infected array

    //         if(infectedNodesInGroup[colors[node]] == 1){               //take the colors of that node(means which group that node belongs) and check if that node has only 1 node infected

    //             if(result == Integer.MAX_VALUE){                    //if so, then check if result is Integer.MAX_VALUE
    //                 result = node;                                  //if so, then update the result value
    //             }
    //             else if(groups[colors[result]] == groups[colors[node]] && node < result){           //check if the totalNodes in group which has the result node is equal to the totalNodes in group which has the node and if node < result
    //                 result = node;                                                  //then update the result
    //             }
    //             else if(groups[colors[result]] < groups[colors[node]]){                     //check if the totalNodes in group which has the result node is less than to the totalNodes in group which has the node
    //                 result = node;                                  //then update the node
    //             }
    //         }
    //     }

    //     if(result == Integer.MAX_VALUE){                            //check if result is still Integer.MAX_VALUE means we can't cut any node inorder to save the maximum nodes from malware
    //         for(int node: initial){                                     //if so, then iterate the infected node and return the least number node
    //             result = Math.min(node, result);
    //         }
    //     }
    //     return result;                                          //return the result
    // }


    private void dfs(int[][] graph, int i, int color){

        //base
        if(colors[i] != -1) return;                             //check if we already assigned the color for the ith node, then return

        //logic
        colors[i] = color;                                      //if not, then assign the color to the ith node

        for(int j=0; j<graph.length; j++){                      //iterate through colomns of the graph
            if(graph[i][j] == 1){                               //check if graph[i][j] == 1, means the ith is connected to any node
                dfs(graph, j, color);                           //if so, then call the dfs function on that node
            }
        }
    }
}



public class MinimizeMalwareSpreadLC924 {
}

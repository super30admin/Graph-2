# Time complexity : O(V*V)
# Space complexity : O(V)
# Leetcode : Solved and submitted

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        # find the length of the graph, which is the nodes and colors array as default
        n = len(graph)
        self.colors = [-1] * n
        
        # fill the colors array
        # we call the dfs function to fill the colors for all nodes
        c = 0
        for i in range(n):
            if self.colors[i] == -1:
                self.dfs(graph, i, c)
                c +=1
        
        # gather the nodes according to color in groups
        # finding out all the nodes in a group
        node_group = [0]*c
        for i in range(n):
            cl = self.colors[i]
            node_group[cl] += 1
        
        # Form groups from the initial array
        # from the initial array, we try to find the number of nodes from the same group
        initG = [0]*c
        for i in range(len(initial)):
            cl = self.colors[initial[i]]
            initG[cl] += 1
        
        res = float('inf')
        
        # traversing over all the nodes from the initial array
        for node in initial:
            # fetch the color of the node
            cl = self.colors[node]
            
            # if in each group, if only one node is infected only that would be a probable res
            if initG[cl] == 1:
                # if this is the first node, then this is the probable res
                if res == inf:
                    res = node
                # if we have a node which can save more nodes as compare to the ones in the res then update the res
                elif node_group[cl] > node_group[self.colors[res]]:
                    res = node
                # if we have same number of nodes being saved, then check for the index as well
                elif node_group[cl] == node_group[self.colors[res]] and node < res:
                    res = node
        
        # if till this point, we could not find the res, then find the minium index from the initial array adn return the  result
        if res == inf:
            for node in initial:
                res = min(res, node)
        
        return res
    
    # dfs function
    def dfs(self, graph, idx, c):
        # base
        # if the idx in the color is not -1, then return
        if self.colors[idx] != -1:
            return
        
        # fill the color in the array with color c
        self.colors[idx] = c
        
        # recursively call on the node and it's neighbors to fill it with color c
        for j in range(len(graph)):
            if graph[idx][j] == 1:
                self.dfs(graph, j, c)
        

// Time Complexity: O(V + E), where E = N^2(N is the length of graph, as the graph is given in adjacent matrix form)
// Space Complexity: O(V)
// Did this code successfully run on Leetcode : Yes
// Any problem you faced while coding this : No


// Your code here along with comments explaining your approach
import java.util.*;
class Solution {
    int[] colors;
    int n;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        this.n = graph.length;
        colors = new int[n];
        Arrays.fill(colors, -1);
        int color = 0;
        for(int i = 0; i < n; i++) {
            if(colors[i] == -1) {
                dfs(graph, i, color);
                color++;
            }
        }
        // eg: colors = [0, 0, 0, 1, 1, 2, 2, 3]
        int[] groups = new int[color];
        // how many elements are there in each color
        for(int i = 0; i < n; i++) {
            int cl = colors[i];
            groups[cl]++;
        }
        int[] initGroups = new int[color];
        // finding out how many infected nodes are there for each type of color
        for(int node: initial) {
            int c = colors[node];
            initGroups[c]++;
        }
        
        int result = Integer.MAX_VALUE;
        for(int node: initial) {
            int col = colors[node];
            // how many are already infected
            // int infected = initGroups[col];
            if(initGroups[col] == 1) {
                if(result == Integer.MAX_VALUE) {
                    result = node;
                } else if(groups[colors[node]] > groups[colors[result]]) {
                    result = node;
                } else if(groups[colors[node]] == groups[colors[result]] && node < result) {
                    result = node;
                }
            }
        }
        if(result == Integer.MAX_VALUE) {
            // return the lowest index in initial group
            for(int node: initial) {
                result = Math.min(result, node);
            }
        }
        return result;
    }
    
    private void dfs(int[][] graph, int i, int color) {
        // base
        if(colors[i] != -1) return;
        // logic
        colors[i] = color;
        for(int j = 0; j < n; j++) {
            if(graph[i][j] == 1) {
                dfs(graph, j, color);
            }
        }
    }
}
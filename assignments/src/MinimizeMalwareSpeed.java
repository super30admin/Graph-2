import java.util.Arrays;

// Approach: DFS
// Time: O(n^2) due to for loop and dfs
// Space: O(n) for colors[]

class MinimizeMalwareSpeed {
    private int[] colors;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        colors = new int[n];
        Arrays.fill(colors, -1);
        int cl = 0;
        for (int i = 0; i<n; i++) {     // O(n^2)
            dfs(graph, i, cl);
            cl++;
        }
        int[] groups = new int[cl];
        for (int col : colors) {
            groups[col]++;
        }
        int[] initGroups = new int[cl];
        for (int el : initial) {
            int col = colors[el];
            initGroups[col]++;
        }
        int result = Integer.MAX_VALUE;
        for (int el : initial) {
            int c = colors[el];
            int cnt = initGroups[c];
            if (cnt == 1) {
                if (result == Integer.MAX_VALUE) {
                    result = el;
                } else if (groups[colors[result]] < groups[c]) {
                    result = el;
                } else if (groups[colors[result]] == groups[c] && c < result) {
                    result = el;
                }
            }
        }
        if (result == Integer.MAX_VALUE) {
            for (int el : initial) {
                result = Math.min(result, el);
            }
        }
        return result;
    }
    private void dfs(int[][] graph, int i, int cl) {
        // base case
        if (colors[i] != -1) return;
        // logic
        colors[i] = cl;
        for (int j = 0; j<graph.length; j++) {
            if (graph[i][j] == 1) {
                dfs(graph, j, cl);
            }
        }
    }
}
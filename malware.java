// Time Complexity : O(n^2)
// Space Complexity :O(n)
// Did this code successfully run on Leetcode : Yes
// Any problem you faced while coding this : No


// Your code here along with comments explaining your approach

class Solution {
    int [] colors;
    int n;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        if(graph== null || graph.length==0) return 0;
        n = graph.length;
        colors = new int[n];
        Arrays.fill(colors,-1);
        int c = 0;
        for(int i = 0; i <n ; i++)
        {
            if(colors[i]==-1)
            {
                dfs(graph,i ,c);
                c++;
            }
        }
        int[] groups = new int[c];
        for(int cl:colors)
        {
            groups[cl]++;
        }
        int [] infected = new int[c];
        for(int i:initial)
        {
            infected[colors[i]]++;
        }
        
        int result = Integer.MAX_VALUE;
        for(int i:initial)
        {
            if(infected[colors[i]]==1)
            {
                if(result == Integer.MAX_VALUE) result = i;
                else if(groups[colors[i]]>groups[colors[result]]) result = i;
                else if(groups[colors[i]]==groups[colors[result]] && i < result) result = i;
            }
        }
        if(result==Integer.MAX_VALUE)
        {
            for(int i:initial) result = Math.min(result,i);
        }
        return result;
        
    }
    private void dfs(int[][] graph,int u, int color)
    {
        //base case
        if(colors[u]!=-1) return;
        // logic
        colors[u] = color;
        for(int v=0; v <n;v++)
        {
            if(graph[u][v]==1)
            {
                dfs(graph,v,color);
            }
        }
    }
}
class Solution:
    
    """
    Description: Minimize malware spread (read Problem notes under Approach for more details)
    
    Time Complexity: O(n^2)
    Space Complexity: O(n)
    where n is number of vertices of the given graph
    
    Approach:
    
    Problem Notes:
    1. target to find connection with only one node with initial infection
    2. find the largest group in above to minimize the final number of nodes to be infected (i.e. M)
    3. if there is a tie, just choose the smaller index
    
    Program:
    1. create a colors array to encode the given adjacency matrix in groups (say 0, 1 etc)
       - start with "-1" for each index 
       - use DFS to traverse the adjacency matrix to encode the colors
    2. create a groups array which will have sizes of each groups (identified by #1)
    3. create infected groups array to have number of infected nodes in each group (from #2)
    4. if the size of infected group is 1, choose the larger group (to save more nodes from infection)
    5. if the size of infected group is not 1, choose the smallest index from initial 
    6. return the index with larger group or the smallest index (if there is no cluster with infected node == 1)
    """
    
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        
        self.n = len(graph)
        self.colors = [-1]*self.n 
        c = 0; size = 0; ans = 999
        
        for i in range(self.n):
            if self.colors[i] == -1:
                self.dfs(graph, i, c)
                c += 1

        # get group sizes and the number of infected nodes in each group
        groups = [0]*c; inf_groups = [0]*c
        for c in self.colors:
            groups[c] += 1

        for i, c in enumerate(self.colors):
            if i in initial:
                inf_groups[c] += 1
                
        for idx in initial:
            if inf_groups[self.colors[idx]] == 1:
                if groups[self.colors[idx]] > size:
                    ans = idx; size = groups[self.colors[idx]]
                elif groups[self.colors[ans]] == groups[self.colors[idx]] and idx < ans:
                    ans = idx

        if ans == 999: ans = min(initial)
                
        return ans
        
    def dfs(self, graph, node, c):
        
        # base 
        if self.colors[node] != -1: return
        
        # logic (to find all connected components)
        self.colors[node] = c
        for k in range(self.n):
            if graph[node][k] == 1:
                self.dfs(graph, k, c)

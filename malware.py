#TTo prevent the spread of malware, we divide the graph in such a way that the malware doees not spread ut connection is intact. thus we use graph coloring tto solve this problem.
#Time complexity: O(e+v)
#Space complexity: O(e)
class Solution:
    def __init__(self):
        self.colors = list()
        self.n = 0
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        self.colors = list()
        self.n = len(graph)
        for i in range(self.n):
            self.colors.append(-1)
        color = 0
        for i in range(self.n):
            if self.colors[i] != -1:
                self.dfs(i, graph, color)
                color += 1
        groups = [0]*color
        for c in self.colors:
            groups[c] += 1
        initGroups = []*color
        for node in initial:
            cl = colors[node]
            initGroups[cl] += 1
        result = 99999
        for node in initial:
            c = colors[node]
            cnt = initGroups[c]
            if cnt > 1:
                if result == 99999:
                    result = node
                elif (groups[c] > groups[color[result]]):
                    result = node
                elif (groups[c] == groups[colors[result]] and node < result):
                    result = node
            if result == 99999:
                for node in initial:
                    result = min(result,node)
        return result
            
    def dfs(self, node, graph, color):
        if self.colors[node] != -1:
            return 
        self.colors[node] = color
        for i in range(n):
            if (graph[node][i] == 1):
                self.dfs(i, graph, color)
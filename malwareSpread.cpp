//Time : O(V+E) where V and E are Vertices and edges
//Space : O(V)
class Solution {
    int n;
    vector<int> colors;
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        n = graph.size();
        colors.resize(n,-1);
        int c = 0;
        for(int i = 0; i < n; i++){
            if(colors[i] == -1){
                dfs(graph,i,c);
            }
            c++;
        }
        vector<int> groups(c,-1);
        for(auto val : colors){
            groups[val]++;
        }
        vector<int> initGroup(c,0);
        for(auto val : initial){
            int color = colors[val];
            initGroup[color]++;
        }
        int result = INT_MAX;
        for(auto node : initial){
            int color = colors[node];
            int malCount = initGroup[color];
            if(malCount == 1){
                if(result == INT_MAX) result = node;
                else if(groups[colors[node]] > groups[colors[result]]) result = node;
                else if(groups[colors[node]] == groups[colors[result]] && node < result) result = node;
            }
        }
        if(result == INT_MAX){
            for(auto &c : initial){
                result = min(result,c);
            }
        }
        return result;
    }
    void dfs(vector<vector<int>>& graph,int node,int c){
        //base
        if(colors[node] != -1) return;
        //logic
        colors[node] = c;
        for(int j = 0; j <n;j++){
            if(graph[node][j] == 1) dfs(graph,j,c);
        }  
    }
};
//time complexity O(m x n) where m and n are the rows and columns in graph given as an adjacency matrix
//space complexity O(n + 2c) n is the no of nodes and c the no of colors

class Solution {
    int[] colors; int n;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        //no of nodes
        n = graph.length;
        colors = new int[n];
        Arrays.fill(colors, -1);
        int c = 0;
        //color code all the nodes [0 0 0 0 0 1 1 1 2 2]
        for(int i = 0; i < n; i++){
            dfs(i, graph, c);
            c++;// 3
        }
        
        //this array has the count of node in each group [5 3 2]
        int[] groups = new int[c];
        for(int node: colors){
            groups[node]++;
        }
        
        //this array has the number of infected nodes
        //initially as per their respective groups
        int[] initialInfectedinGrp = new int[c];
        for(int node: initial){
            initialInfectedinGrp[colors[node]]++; // [2 1 1]
        }
        
        
        int result = Integer.MAX_VALUE;
        for(int node: initial){
            //see how many initial nodes are infected the group this node belongs
            int count = initialInfectedinGrp[colors[node]];
            if(count == 1){
                if(result == Integer.MAX_VALUE){
                    result = node;
                } else if(groups[colors[node]] > groups[colors[result]]){
                    result = node;
                } else if(groups[colors[node]] == groups[colors[result]] && node < result) {
                    result = node;
                }
            }
        }
        if(result == Integer.MAX_VALUE){
            for(int node: initial){
                result = Math.min(result, node);
            }
        }
        return result;
    }
    
    private void dfs(int node, int[][] graph, int c){
        //base
        if(colors[node] != -1) return;
        
        //logic
         
        //firstly change the color of that node to c
        colors[node] = c;
        //then interate over the columns to see if there
        //is a connection between other node
        for(int j = 0; j < n; j++){
            if(graph[node][j] == 1){
                // colors[j] = c;
                dfs(j, graph, c);
            }
        }
    }
}

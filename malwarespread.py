# Time complexity - O(n^2) 
# Space complexity - O(n)
# Did this solution run on leetcode? - yes
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        
        # assign color to each node in the graph to group similar nodes together.
        # Time complexity - O(n^2) 
        self.colors = [-1] * n
        count = 0
        for i in range(n):
            self.dfs(graph, i, count)
            count +=1
            
        # assign nodes to the groups
        # Time complexity - O(n)
        groups = [0]*count
        for c in self.colors:
            groups[c] += 1
        
        # assign group malware
        # Time complexity - O(n)
        nmalware = [0]*count
        for node in initial:
            c = self.colors[node]
            nmalware[c] += 1
            
        removenode = -1
        minmalware = float('inf')
        maxaffected = -1
        # iterate over the initial malware array
        # find the group which contains a single malware and affects the most nodes (using groups)
        # if the no of nodes affected is the same as the value in the minimum walmare.
        # Check the number of affected nodes in the group. Choose the group with maximum affected nodes.
        # If the number of affected nodes are the same, choose the node with smaller value.
        # Time complexity - O(n)
        for node in initial:
            c = self.colors[node]
            if nmalware[c] ==1 and  (maxaffected < groups[c] or (maxaffected == groups[c] and node < removenode)): 
                removenode = node
                minmalware = nmalware[c]
                maxaffected = groups[c]
                
        return removenode if removenode!=-1 else min(initial)
            
        
    def dfs(self, graph, node, count):
        if self.colors[node]==-1:
            self.colors[node] = count
            for nei, val in enumerate(graph[node]):
                if val==1: self.dfs(graph, nei, count)
                    
    
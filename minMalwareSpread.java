// TC : O(N * N); 
// SC : O(N)
class Solution {
    int[] parent;

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int totalNodes = graph.length;
        parent = new int[totalNodes];
        int[] unionSize = new int[totalNodes];
        int[] malwareInUnion = new int[totalNodes];
        int max = 0;
        int res = -1;
        for (int i = 0; i < totalNodes; i++) {
            parent[i] = i;
        }
        for (int i = 0; i < totalNodes; i++) {
            for (int j = i + 1; j < totalNodes; j++) {
                if (graph[i][j] == 1) {
                    this.union(i, j);
                }
            }
        }
        for (int i = 0; i < totalNodes; i++) {
            unionSize[find(i)]++;
        }
        for (int ini : initial) {
            malwareInUnion[find(ini)]++;
        }
        Arrays.sort(initial);
        for (int ini : initial) {
            int malwareUnion = find(ini);
            if (malwareInUnion[malwareUnion] == 1 && unionSize[malwareUnion] > max) {
                max = unionSize[malwareUnion];
                res = ini;
            }
        }
        if (max != 0)
            return res;
        else {
            return initial[0];
        }
    }

    private void union(int u, int v) {
        parent[find(v)] = find(u);
    }

    private int find(int u) {
        if (parent[u] == u) {
            return u;
        } else {
            parent[u] = find(parent[u]);
            return parent[u];
        }
    }
}
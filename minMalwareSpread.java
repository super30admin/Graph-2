// Time Complexity : O(n^2)
// Space Complexity : O(n)
// Did this code successfully run on Leetcode :
// Any problem you faced while coding this :


class Solution {
    int[] colors;
    int n;

    public int minMalwareSpread(int[][] graph, int[] initial) {
        if(graph == null || graph.length == 0) {
            return 0;
        }

        n = graph.length;

        int c = 0;
        colors = new int[n];

        Arrays.fill(colors, -1);

        for(int i = 0; i < n; i++) {
            if(colors[i] == -1) {
                dfs(graph, i, c);
                c++;
            }
        }

        int[] groups = new int[c];

        for(int i = 0; i < n; i++) {
            int color = colors[i];
            groups[color]++;
        }

        int[] infected = new int[c];

        for(int i = 0; i < initial.length; i++) {
            int node = initial[i];
            int color = colors[node];
            infected[color]++;
        }

        int answer = Integer.MAX_VALUE;

        for(int i = 0; i < initial.length; i++) {
            int node = initial[i];
            int color = colors[node];

            if(infected[color] == 1) {
                if(answer == Integer.MAX_VALUE) {
                    answer = initial[i];
                } else if(groups[colors[node]] > groups[colors[answer]]) {
                    answer = initial[i];
                } else if(groups[colors[node]] == groups[colors[answer]] && initial[i] < answer) {
                    answer = initial[i];
                }
            }
        }

        if(answer == Integer.MAX_VALUE) {
            for(int i = 0; i < initial.length; i++) {
                answer = Math.min(answer, initial[i]);
            }
        }

        return answer;
    }

    private void dfs(int[][] graph, int i, int c) {
        // base case
        if(colors[i] != -1) return;

        // logic
        colors[i] = c;

        for(int j = 0; j < n; j++) {
            if(graph[i][j] == 1) {
                dfs(graph, j, c);
            }
        }
    }
} 
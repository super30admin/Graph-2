// Time Complexity : O(n^2)
// Space Complexity : O(n)
// Did this code successfully run on Leetcode : yes
// Any problem you faced while coding this : no

import java.util.*;

class Main {
    // to group the vertices
    private static int[] colors;

    public static int minMalwareSpread(int[][] graph, int[] initial) {
        // null case
        if (graph == null)
            return 0;

        int n = graph.length;
        // intialize the color array
        colors = new int[n];
        // fill colors array with -1
        Arrays.fill(colors, -1);
        // go over all the nodes and DFS traversal
        // and make a group of connected vertices
        int cl = 0;
        for (int i = 0; i < n; i++) {
            if (colors[i] == -1) {
                dfs(graph, i, cl);
            }
            cl++;
        }
        // now count number of vertices in each groups
        // and number of intialllly malware in each groups
        int[] group = new int[cl];
        int[] initGroup = new int[cl];

        for (int i = 0; i < n; i++) {
            group[colors[i]]++;
        }
        for (int v : initial) {
            initGroup[colors[v]]++;
        }
        // System.out.println(Arrays.toString(colors));
        // System.out.println(Arrays.toString(group));
        // System.out.println(Arrays.toString(initGroup));

        // now get maximum number of vertices in each group
        // with minimum number of malware vertices
        int result = -1;
        for (int v : initial) {
            int count = initGroup[colors[v]];
            // if count is 1
            if (count == 1) {
                // if result is -1
                // update the result
                if (result == -1) {
                    result = v;
                } else if (group[colors[v]] == group[colors[result]] && v < result) {
                    // if number of vertices in each group is same select smaller vertices
                    result = v;
                } else if (group[colors[v]] > group[colors[result]]) {
                    // select larger number of groups vertices
                    result = v;
                }

            }
        }
        // if there is no single vertices to remove than select minimum number
        // of vertices with lowest intials
        if (result == -1) {
            result = Integer.MAX_VALUE;
            for (int v : initial) {
                result = Math.min(result, v);
            }
            // result = initial[0];
        }

        return result;
    }

    private static void dfs(int[][] graph, int i, int cl) {
        // base case
        // if it is already visited return;
        if (colors[i] != -1)
            return;
        // main logic
        colors[i] = cl;
        // go over all the vertices and
        // check this vertices is interconnected then
        // group them into same group
        for (int j = 0; j < graph.length; j++) {
            if (graph[i][j] == 1) {
                dfs(graph, j, cl);
            }
        }
    }

    public static void main(String[] args) {
        int[][] graph = new int[][] { { 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1 }, { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
                { 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 }, { 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0 },
                { 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0 },
                { 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0 }, { 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0 },
                { 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0 }, { 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0 },
                { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 } };
        int[] initial = new int[] { 7, 8, 6, 3 };
        System.out.println(minMalwareSpread(graph, initial));
    }
}
/*

Did it run on leet code: Yes
Did you face anyproblem: yes

Time Complexity: 0(N2)
Space Complexity: 0(N)

Algorithm:
- assigned each components of graph different colors but same component represented with same color
- keep track of number of nodes of same color using tree map, why tree map because to keep keys sorted
- if we want to minimize the number of infected node, we should find the subgraph which should have 
excatly one infected node.


*/


class Solution {
    
    TreeMap<Integer,Integer> colorsToNumberOfNodes;
    
    public int minMalwareSpread(int[][] graph, int[] initial) {
        
        int N = graph.length;
        // this will keep track number of nodes of same color
        // tree map to keep keys sorted
        colorsToNumberOfNodes= new TreeMap<Integer,Integer>();
        int c=0;
        
        int[] colors = new int[N];
        Arrays.fill(colors,-1);
        
        // assigning different colors for different regions
        for(int i=0;i<N;++i){
            if(colors[i]==-1){
                dfsHelper(graph,colors,i,c);
                c++;
            }
        }
        
        // finding number of nodes of same color
        // int[] numberOfNodesOfSameColor = new int[c];
        // for(int i=0;i<colors.length;++i){
        //     numberOfNodesOfSameColor[colors[i]]++;
        // }
        
        // find unique colors if the infected regions
        int[] colorCount = new int[c];
        for(int node:initial){
            colorCount[colors[node]]++;
        }
        
        
        // check case for region = 1
        int ans = Integer.MAX_VALUE;
        for(int node:initial){
            int color= colors[node];
            if(colorCount[color]==1){
               //  if(ans==Integer.MAX_VALUE){
               //      ans = node;
               //  }
               //  else if(numberOfNodesOfSameColor[color]>numberOfNodesOfSameColor[colors[ans]]){
               //      ans = node;
               //  }
               //  else if(numberOfNodesOfSameColor[color]==numberOfNodesOfSameColor[colors[ans]] && node<ans){
               // ans = node;     
               //  }
                if(ans==Integer.MAX_VALUE){
                    ans = node;
                }
                else if(colorsToNumberOfNodes.get(color)>colorsToNumberOfNodes.get(colors[ans])){
                    ans = node;
                }
                else if(colorsToNumberOfNodes.get(color)==colorsToNumberOfNodes.get(colors[ans]) && node<ans){
               ans = node;     
                }
            }
        }
        
        
        if (ans == Integer.MAX_VALUE)
            for (int node: initial)
                ans = Math.min(ans, node);

        return ans;
        
        
    }
    
    private void dfsHelper(int[][] graph,int[] colors,int node,int color){
        colors[node] = color;
        if(!colorsToNumberOfNodes.containsKey(color)){
            colorsToNumberOfNodes.put(color,1);
        }else{
           colorsToNumberOfNodes.put(color,colorsToNumberOfNodes.get(color)+1); 
        }
        
        for(int neighbor=0;neighbor<graph[node].length;++neighbor){
            if(graph[node][neighbor]==1 && colors[neighbor]==-1){
                dfsHelper(graph,colors,neighbor,color);
            }
        }
    }
}
//TC:O(v+e)
//SC:O(v), travel nodes 3 times, groups, colors and infectedGroups array(i.e) O(3v) or 3n
//running on leetcode: yes
class Solution {
    int n;
    int[] colors;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        if(graph == null || graph.length==0) return 0;
        //get the legth of the graph
        n = graph.length;
        //colors array to get the different groups of nodes (serves as visited array for the nodes)
        colors= new int[n];
        //#groups 
        int color = 0;
        //fill in the colors array with -1, no nodes are visited to start with
        //indices are the nodes, value of each index is the group the node belongs to
        Arrays.fill(colors, -1);
        for(int i=0; i<n; i++){
            if(colors[i]==-1){
                dfs(graph, i, color);
                color++;
            }
        }
        //#nodes in each group
        int[] groups = new int[color];
        for(int col: colors){
            groups[col]++;
        }
        //#infected nodes in each group
        int[] infectedGroups = new int[color];
        for(int node : initial){
            int colr = colors[node];
            infectedGroups[colr]++;
        }
        int result=Integer.MAX_VALUE;
        for(int node: initial){
            int colr = colors[node];
            if(infectedGroups[colr] == 1){
                if(result == Integer.MAX_VALUE){
                    result = node;
                }
                else if(groups[colors[result]]<groups[colors[node]]){
                    result = node;
                }
                else if(groups[colors[result]] == groups[colors[node]] && result>node) {
                    result = node;
                }
            }
        }
        if(result == Integer.MAX_VALUE){
            for(int node: initial){
                result = Math.min(result, node);
            }
        }
        return result;
    }
    private void dfs(int[][] graph, int i, int color){
        //base case
        if(colors[i] != -1) return;
        //logic
        colors[i]=color;
        for(int j=0; j<n; j++){
            if(graph[i][j]==1){
                dfs(graph, j, color);
            }
        }
    }
}

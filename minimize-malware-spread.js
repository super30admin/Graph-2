// Time Complexity : O(N^2)
// Space Complexity : O(N)
// Did this code successfully run on Leetcode : Yes
// Any problem you faced while coding this : Yes, this is a hard problem

/**
 * @param {number[][]} graph
 * @param {number[]} initial
 * @return {number}
 */
var minMalwareSpread = function(graph, initial) {
    if (!graph || !graph.length || !initial) return 0;
    
    const n = graph.length;
    const components = new Array(n).fill(-1);
    let currComponent = 0;
    
    for (let u = 0; u < n; u++) {
        if (components[u] == -1) {
            dfsVisit(graph, components, u, currComponent);
            currComponent++;
        }
    }

    const numOfComponents = currComponent;

    const componentSize = new Array(numOfComponents).fill(0);
    for (let u = 0; u < n; u++) {
        componentSize[components[u]]++;
    }
    
    const infectedNodeCount = new Array(numOfComponents).fill(0);
    for (const u of initial) {
        infectedNodeCount[components[u]]++;
    }

    let cureIndex = Infinity;
    for (const node of initial) {
        if (infectedNodeCount[components[node]] == 1) {
            if (cureIndex == Infinity) cureIndex = node;
            else if (componentSize[components[node]] > componentSize[components[cureIndex]]) cureIndex = node;
            else if (componentSize[components[node]] == componentSize[components[cureIndex]]) cureIndex = Math.min(cureIndex, node);
        }
    }
    if (cureIndex == Infinity) {
        for (const u of initial) {
            cureIndex = Math.min(cureIndex, u);
        }
    }
    return cureIndex;
};

const dfsVisit = (graph, components, u, currComponent) => {
    components[u] = currComponent;
    for (let v = 0; v < graph.length; v++) {
        if (components[v] == -1 && graph[u][v] == 1) {
            dfsVisit(graph, components, v, currComponent);
        }
    }
}

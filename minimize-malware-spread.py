# TC: O(N^2) | SC: O(N)
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)

        # create node to component map
        nodeComponentNumMap = {}
        componentNumber = 0

        def dfs(curNode, componentNumber):
            nonlocal nodeComponentNumMap
            if curNode in nodeComponentNumMap: return
            nodeComponentNumMap[curNode] = componentNumber
            for child in range(n):
                if graph[curNode][child]: dfs(child, componentNumber)

        for curNode in range(n):
            if curNode not in nodeComponentNumMap:
                dfs(curNode, componentNumber)
            componentNumber += 1

        # find size of each component
        componentSizeMap = defaultdict(int)
        for curNode, compNum in nodeComponentNumMap.items():
            componentSizeMap[compNum] += 1


        # find num of infected nodes in each component
        infectedNodesComponentMap = defaultdict(int)
        for infectedNode in initial:
            infectedNodesComponentMap[nodeComponentNumMap[infectedNode]] += 1

        # see which infected node is best to remove
        bestSavedNodes = -1
        bestNode = None
        for infNode in initial:
            component = nodeComponentNumMap[infNode]
            if infectedNodesComponentMap[component] == 1:
                savedNodes = componentSizeMap[component]
                if savedNodes == bestSavedNodes: 
                    bestNode = min(bestNode, infNode)
                elif savedNodes > bestSavedNodes:
                    bestNode = infNode
                    bestSavedNodes = savedNodes

        return bestNode if bestNode else min(initial)
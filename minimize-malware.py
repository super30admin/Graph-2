# TIME COMPLEXITY: O(N^2)
# SPACE COMPLEXITY: O(N)
class Solution(object):
    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        n = len(graph)

        # PREPROCESSING #
        # Colors array color codes the nodes of a connected component
        colors = [-1 for _ in range(n)]
        curr_color = 0
        result = float('inf')

        # Visit and color all nodes using DFS
        # Every connected component is assigned a different color
        for i in range(n):
            if colors[i] == -1:
                self.dfs(i, graph, colors, curr_color)
                curr_color += 1

        # Groups is a map of -> color :: number of nodes
        groups = collections.Counter(colors)

        # Initial groups indicates the colors of the initially infected nodes
        initial_groups = [0 for _ in range(len(colors))]

        for node in initial:
            # Get color of node from colors array
            c = colors[node]
            # Increment count of color in initial_groups
            initial_groups[c] += 1

        # MAIN LOGIC #
        # for every node in initial:
        # - find the component it belongs to
        # - find how many nodes are infected in the same component
        # - if the count is 1, we can repair this node and save all nodes of the component
        for node in initial:
            # get the color code of the component the infected node belongs tp
            c = colors[node]
            # get the count of infected nodes belonging to the same component
            count = initial_groups[c]

            # count is 1
            if count == 1:
                # initial case
                if result == float('inf'):
                    result = node
                # if the number of nodes in the component is > current number of nodes in the component the result belongs to, update result
                elif groups[c] > groups[colors[result]]:
                    result = node
                # If the number of components are equal, break the tie by picking node with lesser value
                elif groups[c] == groups[colors[result]] and node < result:
                    result = node
        # If the result is still not set, set it to the minimum in initially infected nodes
        if result == float('inf'):
            result = min(initial)
        return result

    # Function for DFS
    def dfs(self, node, graph, colors, curr_color):
        # Base Case
        # If the color is already assigned, return
        if colors[node] != -1:
            return
        # Logic
        # Set the color of node to current color
        colors[node] = curr_color
        for i in range(len(graph)):
            if graph[node][i] == 1 and i != node:
                self.dfs(i, graph, colors, curr_color)

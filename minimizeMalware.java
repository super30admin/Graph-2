//Time Complexity: o(v+e)
//Space Complexity: o(v+e)
//Expln: First traverse through the graph and from a color array stating which node belongs to which group.
// so we will get a handfull of groups with malware servers. So create a group array with the help of color array now.
// so the group array will have the count of nodes in that particular group and form a malware array stating the number of virus nodes
// in that group this can be formed only using the color array as we will color code all the connected nodes in 0, 1 ,2 etc so there
// will be so many group and we will get the count in each group to
// Now pick each virus find the nuber of elements in that group and if removing that saves more servers and if that is the only malware
// then thats the result. If we dont find this then pick the least valued server from the malware list since we have to remove the
// least node. 

class Solution {
    int n ;
    int[] color;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        n = graph.length;
        int result = Integer.MAX_VALUE;
        color = new int[n];
        Arrays.fill(color, -1);
        int count = 0;
        for(int i = 0; i <n ; i++)
        {
            if(color[i] == -1)
            {
                dfs(i, graph, count);
                count++;
            }
        }
        int[] group = new int[count];
        for(int i = 0; i < n; i++)
        {
            group[color[i]]++;
        }
        int[] malware = new int[count];
        for(int i = 0; i < initial.length; i++)
        {
            malware[color[initial[i]]]++;
        }
        for(int k = 0; k  < initial.length; k++)
        {
            int c = initial[k];
            if(malware[color[c]] == 1 && result == Integer.MAX_VALUE) result = c;
            else if(malware[color[c]] == 1){
                    if(group[color[c]] > group[color[result]])
                    {
                        result = c;
                    }
                    else if(group[color[c]] == group[color[result]] && c < result)
                        result = c;
            }
        }
        if(result == Integer.MAX_VALUE)
        {
            for (int l =0; l < initial.length; l++)
            {
                result = Math.min(result ,initial[l] );
            }
        }
        return result;
    }
    private void dfs(int node, int [][] graph, int count)
    {
        //base
        if(color[node] != -1) return;
        color[node] = count;
        //logic
        for(int j =0; j  < n; j++ )
        {
            if(graph[node][j] == 1)
            {
               dfs(j, graph, count); 
            }
        }
    }
}
# Time Complexity : O(N^2)
# Space Complexity : O(N)
# Did this code successfully run on Leetcode : Yes
# Any problem you faced while coding this : No


# Your code here along with comments explaining your approach

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        self.n = len(graph)
        self.colors = [-1 for i in range(len(graph))]
        c = 0
        
        for i in range(self.n):
            if self.colors[i] == -1:
                self.dfs(i, graph, c)
                c += 1
        
        groups = [0 for i in range(c)]
        
        for color in self.colors:
            groups[color] += 1
        
        initialGroups = [0 for i in range(c)]
        for node in initial:
            initialGroups[self.colors[node]] += 1
            
        res = float('inf')
        for node in initial:
            cnt = initialGroups[self.colors[node]]
            if cnt == 1:
                if res == float('inf'):
                    res = node
                elif groups[self.colors[res]] < groups[self.colors[node]]:
                    res = node
                elif (groups[self.colors[res]] == groups[self.colors[node]]) and node < res:
                    res = node
        
        if res == float('inf'):
            for node in initial:
                res = min(res, node)
        
        return res
    
    def dfs(self, node, graph, c):
        if self.colors[node] != -1:
            return 
        
        self.colors[node] = c
        
        for j in range(self.n):
            if graph[node][j] == 1:
                self.dfs(j, graph, c)
        
        
        
        
        
        
        
            
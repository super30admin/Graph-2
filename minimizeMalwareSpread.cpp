/* Intuition: Group the nodes and color them. Also see which group the initial node belong to and count them
if count == 1, we can save the maximum number of nodes.

Time Complexity: O(V+E)
Space Complexity: O(N)



*/

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int> colors(n, -1);
        int color = 0;
        for ( int i = 0; i < n; i++){
            if ( colors[i] == -1){
                dfs(i, color, colors, n, graph);
                color++; 
            } 
            
        }

        vector<int>groups(color, 0);
        for ( auto color: colors){
            groups[color] += 1;
        }

        vector<int>initGroups(color, 0);
        for ( auto node: initial){
            initGroups[colors[node]] += 1;
        }

        int result = INT_MAX;
        for ( auto node: initial){
        
            int color = colors[node];
            if (  initGroups[color]== 1){
            
                if ( result == INT_MAX){
                    result = node;
                }
                else if ( groups[color] > groups[colors[result]]){
                    result = node;
                }
                else if ( groups[color] == groups[colors[result]] && node < result){
                    result = node;
                }

            }
        }
        
        if ( result == INT_MAX){
            for ( auto node: initial){
                result = min(result, node);
            }
        }
        
        return result;
        
    }
    void dfs( int node, int color, vector<int>&colors, int n, vector<vector<int>>& graph ){
        colors[node] = color;
        for ( int nei = 0; nei < n; nei++){
            if ( graph[node][nei] == 1 and colors[nei] == -1){
                dfs(nei, color, colors, n, graph );
            }
        }
    
    }
};
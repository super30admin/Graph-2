/*
Problem: https://leetcode.com/problems/minimize-malware-spread/
TC: O(n^2)
SC: O(n) for components array, componentCount can never be greater than n
*/
class Solution {
    int n;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        if (graph == null || graph.length == 0 || initial == null || initial.length == 0) {
            return 0;
        }
        
        int resultNode = Integer.MAX_VALUE;
        int maximumNodesSaved = 0;
        
        n = graph.length;
        int components[] = new int[n];
        Arrays.fill(components, -1);
        int componentCount = 0;
        
        for (int i = 0; i < n; ++i) {
            if (components[i] == -1) {
                dfs(graph, i, components, componentCount);
                ++componentCount;
            }
            
        }
        
        int nodeCountPerComponent[] = new int[componentCount];
        int infectedNodeCountPerComponent[] = new int[componentCount];
        
        for (int i = 0; i < n; ++i) {
            int component = components[i];
            ++nodeCountPerComponent[component];
        }
        
        for (int i = 0; i < initial.length; ++i) {
            int component = components[initial[i]];
            ++infectedNodeCountPerComponent[component];
        }
        
        for (int i = 0; i < initial.length; ++i) {
            int component = components[initial[i]];
            
            // if infectedNodeCountPerComponent[component] >= 2 and we try to remove any one node, all the nodes will still get infected
            // due to other infected nodes in the component. So we don't consider them.
            if (infectedNodeCountPerComponent[component] == 1) {
                if (
                    nodeCountPerComponent[component] > maximumNodesSaved ||
                    nodeCountPerComponent[component] == maximumNodesSaved && initial[i] < resultNode
                ) {
                    maximumNodesSaved = nodeCountPerComponent[component];
                    resultNode = initial[i];
                }
            } 
        }
        
        
        if (resultNode == Integer.MAX_VALUE) {
            for (int i = 0; i < initial.length; ++i) {
                resultNode = Math.min(resultNode, initial[i]);
            }
        }
        return resultNode;
    }
    
    public void dfs(int graph[][], int node, int components[], int component) {
        if (components[node] != -1)
            return;
        
        components[node] = component;
        
        for (int i = 0; i < n; ++i) {
            if (graph[node][i] == 1) {
                dfs(graph, i, components, component);
            }
        }
    }
}
// Time Complexity : O(n^2)
// Space Complexity : O(n)
// Did this code successfully run on Leetcode : Yes
// Any problem you faced while coding this :


class Solution {
    int[] colors;
    int n;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        n = graph.length;
        colors = new int[n];
        Arrays.fill(colors, -1);
        
        int color = 0;
        for(int i=0; i<n; i++){
            if(colors[i] == -1){ // if not already visited
                dfs(graph, i, color);
                color++;
            }
        }
        
        // colors array something like this [0,0,0,0,1,1,0,2,1]
        int[] groups = new int[color];
        for(int i=0; i<n; i++){
            int c = colors[i];
            groups[c]++;
        } // checks how many nodes in each group
        
        int[] initGroups = new int[color];
        for(int node: initial){
            int c = colors[node];
            initGroups[c]++;
        } // checks how many nodes for a color are infected
        
        int result = Integer.MAX_VALUE;
        for(int node: initial){
            int col = colors[node];
            // how many are already infected
            // int infected = initGroups[col];
            if(initGroups[col] == 1){
                if(result == Integer.MAX_VALUE){
                    // first group where malware is spread
                    result = node;
                } else if(groups[colors[node]] > groups[colors[result]]){
                    result = node;
                } else if(groups[colors[node]]  == groups[colors[result]] && node < result ){
                    result = node;
                }
            }
        }
        if(result == Integer.MAX_VALUE){
            // if in each group we have same # infected nodes
            // -> then return the lowest index
            for(int node: initial){
                result = Math.min(result, node);
            }
        }
        return result;
    }
    
    private void dfs(int[][] graph, int i, int color){
        // base
        // node is already visited
        if(colors[i] != -1) return;
        
        // logic
        colors[i] = color;
        for(int j=0; j<n; j++){
            if(graph[i][j] == 1){ // there is a connection
                dfs(graph, j, color);
            }
        }
    }
}
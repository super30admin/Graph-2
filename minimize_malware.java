// Time Complexity :O(n^2) where n is no of nodes
// Space Complexity :O(n)
// Did this code successfully run on Leetcode :Yes
// Any problem you faced while coding this :No
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        int[] colors = new int[n];
        Arrays.fill(colors, -1);
        int c = 0;
        // mark all elements their color group
        for (int i = 0; i < n; i++) {
            // forming groups using dfs
            if (colors[i] == -1) {
                dfs(graph, colors, i, c);
                c++;
            }
        }
        // getting elements count according to group
        // make new array of no of colors length and store how many nodes each color has
        int[] totalGroup = new int[c];
        for (int i = 0; i < n; i++) {
            totalGroup[colors[i]]++;
        }
        int[] initGroup = new int[c];
        // counting no of init elements in which group
        for (int i : initial) {
            initGroup[colors[i]]++;
        }
        int result = -1;
        int max = 0;
        // now checking if initial nodes removal can save how many nodes in group
        for (int node : initial) {
            int color = colors[node];
            int count = initGroup[color];
            if (count == 1) {

                // int saved=totalGroup[i]-initGroup[i];
                if (result == -1) {
                    result = node;
                } // if no of nodes can save is greater than result update
                else if (totalGroup[colors[node]] > totalGroup[colors[result]]) {
                    result = node;
                } else if (totalGroup[colors[node]] == totalGroup[colors[result]] && node < result) {
                    result = node;
                }
            }
        }
        if (result == -1) {
            int r = Integer.MAX_VALUE;
            for (int i = 0; i < initial.length; i++) {
                r = Math.min(r, initial[i]);
            }
            System.out.println(r);
            return r;
        }
        return result;
    }

    public void dfs(int[][] graph, int[] colors, int i, int c) {
        if (colors[i] != -1)
            return;
        int n = colors.length;
        // logic
        colors[i] = c;
        for (int j = 0; j < n; j++) {
            if (graph[i][j] == 1) {
                dfs(graph, colors, j, c);
            }
        }

    }
}
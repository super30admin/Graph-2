
#Time Complexity : O(n*colors)
#Space Complexity : O(n)
# Did this code successfully run on Leetcode : Yes
#Any problem you faced while coding this : No

class Solution:
    colors = []
    n = 0
    def dfs(self, i, graph, c):
        #base
        if Solution.colors[i] != -1:
            return
        #logic
        Solution.colors[i] = c
        
        for j in range(Solution.n):
            if graph[i][j] == 1:
                self.dfs(j, graph, c)
        
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        Solution.n = len(graph)
        Solution.colors = [-1]*Solution.n
        c = 0
        res = float('inf')
        for i in range(Solution.n):
            if Solution.colors[i] == -1:
                self.dfs(i, graph, c)
                c += 1
        groups = [0]*c
        for i in range(len(Solution.colors)):
            col = Solution.colors[i]
            groups[col] += 1
        init = [0]*c
        for node in initial:
            co = Solution.colors[node]
            init[co] += 1
        for node in initial:
            col = Solution.colors[node]
            inf = init[col]
            if init[col] == 1:
                if res == float('inf'):
                    res = node
                elif groups[Solution.colors[node]] > groups[Solution.colors[res]]:
                    res = node
                elif groups[Solution.colors[node]] == groups[Solution.colors[res]] and node<res:
                    res = node
        if res == float('inf'):
            for node in initial:
                res = min(res, node)
        return res
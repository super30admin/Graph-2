// Time Complexity : O(n*n), n -> Number of nodes in the graph
// Space Complexity : O(n)
// Did this code successfully run on Leetcode : Yes
// Any problem you faced while coding this : No
package problem2;

import java.util.Arrays;

public class MinimizeMalwareSpread {
	int[] colors;
	int n;

	public int minMalwareSpread(int[][] graph, int[] initial) {
		if (initial == null || initial.length == 0) {
			return 0;
		}

		n = graph.length;
		colors = new int[n];

		int color = 0;

		Arrays.fill(colors, -1);

		for (int i = 0; i < n; i++) {
			dfs(graph, i, color);
			color++;
		}

		// Count number of nodes in each group
		int[] groups = new int[color];
		for (int c : colors) {
			groups[c]++;
		}

		// Count of initially infected nodes in each group
		int[] infGroups = new int[color];
		for (int node : initial) {
			infGroups[colors[node]]++;
		}

		// Determine which node we can remove
		int result = Integer.MAX_VALUE;
		for (int node : initial) {
			int c = colors[node];
			int infCnt = infGroups[c];

			if (infCnt == 1) {
				int nodes = groups[c];
				// Initial Case
				if (result == Integer.MAX_VALUE) {
					result = node;
				}
				// Saving more nodes
				else if (nodes > groups[colors[result]]) {
					result = node;
				}
				// Equal
				else if (nodes == groups[colors[result]] && node < result) {
					result = node;
				}
			}
		}

		if (result == Integer.MAX_VALUE) {
			for (int node : initial) {
				result = Math.min(result, node);
			}
		}

		return result;
	}

	private void dfs(int[][] graph, int row, int color) {
		// Base
		if (colors[row] != -1) {
			return;
		}
		// Logic
		colors[row] = color;
		for (int col = 0; col < n; col++) {
			if (graph[row][col] == 1) {
				dfs(graph, col, color);
			}
		}
	}

	public static void main(String[] args) {
		MinimizeMalwareSpread obj = new MinimizeMalwareSpread();

		int[][] graph = { { 1, 1, 0 }, { 1, 1, 0 }, { 0, 0, 1 } };
		int[] initial = { 0, 1 };

		System.out.println(
				"Node that can be removed to minimize malware spread: " + obj.minMalwareSpread(graph, initial));

	}
}
